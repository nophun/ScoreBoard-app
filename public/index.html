<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Card Game Scores</title>
  <link rel="manifest" href="manifest.json">
  <meta name="theme-color" content="#1976d2">
  <link rel="icon" href="icons/favicon.ico" type="image/x-icon">
  <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@300;400;500;700&display=swap" rel="stylesheet">
  <style>
    body { 
      font-family: 'Roboto', sans-serif; 
      margin: 0; 
      display: flex; 
      height: 100vh;
      position: relative;
    }
    
    /* Ensure form controls and buttons inherit the document font (some browsers use OS UI font otherwise) */
    button, input, select, textarea { font-family: inherit; }
    
    .sidebar {
      width: 200px;
      background: #f5f5f5;
      border-right: 2px solid #ddd;
      padding: 20px;
      overflow-y: auto;
      transition: transform 0.3s ease;
      z-index: 1001;
    }
    
    .main-content {
      flex: 1;
      padding: 20px;
      overflow-y: auto;
      position: relative;
    }
    
    /* Prevent the back-to-game button text from wrapping on narrow screens */
    button[onclick="showGame()"] {
      white-space: nowrap;
      flex-shrink: 0;
    }
    
    .game-list {
      max-height: 300px;
      overflow-y: auto;
      margin-bottom: 10px;
      padding-right: 5px;
    }
    
    .game-list::-webkit-scrollbar {
      width: 6px;
    }
    
    .game-list::-webkit-scrollbar-track {
      background: #f1f1f1;
      border-radius: 3px;
    }
    
    .game-list::-webkit-scrollbar-thumb {
      background: #888;
      border-radius: 3px;
    }
    
    .game-list::-webkit-scrollbar-thumb:hover {
      background: #555;
    }
    
    .game-item {
      padding: 6px 10px;
      margin-bottom: 3px;
      background: white;
      border-left: 3px solid transparent;
      cursor: pointer;
      transition: all 0.2s ease;
      display: flex;
      align-items: center;
      justify-content: space-between;
    }
    
    .game-item:hover {
      background: #f5f5f5;
      border-left-color: #007acc;
    }
    
    .game-item.active {
      background: #e3f2fd;
      border-left-color: #007acc;
      font-weight: 600;
    }
    
    .game-name {
      flex: 1;
      font-size: 13px;
      color: #333;
    }
    
    .game-item.active .game-name {
      color: #007acc;
    }
    
    .delete-game {
      background: transparent;
      color: #dc3545;
      border: none;
      padding: 4px 8px;
      cursor: pointer;
      font-size: 16px;
      line-height: 1;
      opacity: 0.6;
      transition: opacity 0.2s ease;
    }
    
    .delete-game:hover {
      opacity: 1;
    }
    
    .game-item.active .delete-game {
      color: #dc3545;
    }
    
    .games-management-list {
      display: flex;
      flex-direction: column;
      gap: 10px;
    }
    
    .games-management-item {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 15px;
      background: white;
      border: 1px solid #ddd;
      border-radius: 6px;
      transition: all 0.2s ease;
    }
    
    .games-management-item:hover {
      background: #f5f5f5;
      border-color: #007acc;
    }
    
    .games-management-item.active {
      background: #e3f2fd;
      border-color: #007acc;
    }
    
    /* Consolidated game-info styles */
    .game-info {
      flex: 1;
      cursor: pointer;
      display: flex;
      flex-direction: column;
      gap: 4px;
      min-width: 0; /* allow truncation in flex layouts */
    }
    
    .game-info-name {
      font-weight: 600;
      font-size: 16px;
      color: #333;
      display: inline-flex;
      align-items: center;
      gap: 8px;
      line-height: 1.1;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
    }
    
    .games-management-item.active .game-info-name {
      color: #007acc;
    }
    
    .game-info-details {
      font-size: 12px;
      color: #666;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }
    
    .game-info-created {
      font-size: 12px;
      color: #666;
      text-align: left;
    }
    
    .game-info-name .offline-badge { margin-left: 8px; font-size: 12px; vertical-align: baseline; }
    
    @media (max-width: 480px) {
      .game-info { align-items: flex-start; }
      .games-management-item { align-items: flex-start; }
      .game-info-details { white-space: normal; }
    }
    
    .new-game-form {
      margin-bottom: 20px;
    }
    
    .new-game-input {
      width: 100%;
      padding: 8px;
      margin-bottom: 10px;
      border: 1px solid #ddd;
      border-radius: 4px;
    }
    
    table { border-collapse: collapse; }
    /* Scroll wrapper and sticky header for History view */
    .table-scroll-wrapper { max-height: 60vh; overflow: auto; overflow-x: auto; -webkit-overflow-scrolling: touch; background: #ffffff; position: relative; }
    .history-table { width: 100%; border-collapse: collapse; margin-bottom: 20px; background: #ffffff; }
    /* Make the sticky header opaque, separated and visually distinct when rows scroll beneath */
    .history-table thead {
      position: sticky;
      top: 0;
      z-index: 2; /* keep header above table body but below sidebar */
      display: table-header-group; /* explicit for older browsers */
    }
    .history-table thead th {
      background: #ffffff; /* fully opaque */
      box-shadow: 0 4px 8px rgba(0,0,0,0.06);
      border-bottom: 2px solid rgba(0,0,0,0.06);
    }
    /* Ensure body cells have an opaque background so header covers cleanly */
    .history-table tbody td {
      background: #ffffff;
    }
    th, td { border: 1px solid #ccc; padding: 6px; text-align: center; }
    input { width: 60px; text-align: center; }
    tfoot td { font-weight: bold; background: #f8f8f8; }
    /* Make first column (Round) slightly narrower for history table */
    .history-table th:first-child,
    .history-table td:first-child {
      width: 60px;
      max-width: 60px;
      white-space: nowrap;
    }
    /* Narrow other columns and truncate overflow with ellipsis */
    .history-table th:not(:first-child),
    .history-table td:not(:first-child) {
      min-width: 60px;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
    }
    .locked input { background: #eee; border: none; }
    button {
      margin: 0;
    }
    /* Generic hover for buttons that use inline styles so a hover effect is visible
    (keeps existing class-based hover rules intact). */
    button:hover {
      filter: brightness(0.96);
      transform: translateY(-1px);
      transition: transform 0.12s ease, filter 0.12s ease;
    }
    
    /* Shared button styles to replace repeated inline styles */
    .sidebar-btn {
      width: 100%;
      margin-bottom: 8px;
      padding: 10px;
      color: white;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      font-size: 15px;
      text-align: center;
    }
    
    .btn-large {
      color: white;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      padding: 8px 16px;
      font-size: 14px;
    }
    
    .btn-small {
      padding: 4px 8px;
      border: none;
      border-radius: 3px;
      cursor: pointer;
      font-size: 12px;
    }
    
    /* Background utility classes */
    .bg-blue { background: #007acc; color: white; }
    .bg-green { background: #28a745; color: white; }
    .bg-grey { background: #6c757d; color: white; }
    .bg-orange { background: #fd7e14; color: white; }
    .bg-purple { background: #6f42c1; color: white; }
    .bg-red { background: #dc3545; color: white; }
    .bg-yellow { background: #ffc107; color: #212529; }
    .bg-white { background: #ededed; color: #212529; }
    
    .bg-blue:hover { background: #005fa3;}
    .bg-green:hover { background: #218838; }
    .bg-grey:hover { background: #545b62; }
    .bg-orange:hover { background: #e06f10; }
    .bg-purple:hover { background: #5a2fa0; }
    .bg-red:hover    { background: #c82333; }
    .bg-yellow:hover { background: #e0a800; }
    .bg-white:hover  { background: #c2c2c2; }
    
    /* Modal Styles */
    .modal {
      display: none;
      position: fixed;
      z-index: 1000;
      left: 0;
      top: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(0,0,0,0.5);
    }
    
    .modal-content {
      background-color: white;
      margin: 10% auto;
      margin-left: calc(50% + 125px);
      transform: translateX(-50%);
      position: relative;
      padding: 20px;
      border-radius: 8px;
      width: 400px;
      max-width: 90%;
      max-height: 80vh;
      overflow: auto;
    }
    
    /* Back-button toast */
    #backToast {
      position: fixed;
      bottom: 16px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(0,0,0,0.85);
      color: #fff;
      padding: 8px 14px;
      border-radius: 18px;
      z-index: 3000;
      font-size: 13px;
      opacity: 0;
      transition: opacity 180ms ease-in-out;
    }
    /* Small debug indicator for popstate events */
    #backDebug {
      position: fixed;
      top: 12px;
      right: 12px;
      background: rgba(0,0,0,0.75);
      color: #fff;
      padding: 6px 10px;
      border-radius: 8px;
      font-size: 12px;
      z-index: 99999;
      display: none;
      pointer-events: none;
    }
    
    .modal-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 20px;
    }
    
    .close {
      color: #aaa;
      font-size: 28px;
      font-weight: bold;
      cursor: pointer;
      background: none;
      border: none;
      padding: 0;
      line-height: 1;
    }
    
    .close:hover {
      color: black;
    }
    
    /* Replacement modal styling */
    .modal-content .alert-icon {
      display: inline-block;
      margin-right: 8px;
      color: #d9534f;
      font-size: 1.05em;
      line-height: 1;
    }
    
    .replacement-list {
      display: flex;
      flex-direction: column;
      gap: 8px;
    }
    
    /* Ensure modals remain visible on small-height screens */
    @media (max-height: 720px) {
      .modal-content {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        margin: 0;
        width: calc(100% - 40px);
        max-width: 480px;
        max-height: 90vh;
        overflow: auto;
      }
    }
    
    .replacement-item {
      display: flex;
      align-items: center;
      gap: 12px;
      background: #fff9f2;
      border: 1px solid #ffe0c2;
      border-radius: 12px;
      padding: 10px 12px;
      box-shadow: 0 1px 0 rgba(0,0,0,0.03);
    }
    
    .replacement-seat {
      font-weight: 600;
      color: #333;
      min-width: 72px;
      text-align: left;
    }
    
    .replacement-desc {
      flex: 1;
      color: #333;
      font-size: 0.97em;
    }
    
    /* Nicer History / Statistics tables */
    .history-table, .statistics-table {
      width: 100%;
      border-collapse: separate;
      border-spacing: 0 6px;
      font-family: 'Roboto', 'Segoe UI', 'Helvetica Neue', Arial, sans-serif;
      font-size: 14px;
      color: #222;
    }
    
    .history-table thead th, .statistics-table thead th {
      text-align: center;
      font-weight: 600;
      color: #333;
      padding: 6px 8px;
      background: #ffffff; /* make header opaque */
      border: none;
    }
    
    /* Ensure table cell fonts are uniform */
    .history-table th, .history-table td,
    .statistics-table th, .statistics-table td {
      font-size: 14px;
    }
    
    .history-table tbody tr, .statistics-table tbody tr {
      background: white;
      box-shadow: 0 1px 0 rgba(0,0,0,0.04);
      border-radius: 8px;
    }
    
    .history-table td, .statistics-table td {
      padding: 6px 8px;
      border: none;
      text-align: center;
      vertical-align: middle;
    }
    
    /* Highlight Avg Score column in statistics */
    .statistics-table th:nth-child(3),
    .statistics-table td:nth-child(3) {
      background: #f0f4ff;
      font-weight: 700;
      color: #1f3c88;
      text-align: center;
    }
    
    .score-inputs {
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      grid-template-rows: repeat(3, auto);
      gap: 15px;
      margin-bottom: 20px;
      justify-items: center;
      max-width: 100%;
      margin-left: auto;
      margin-right: auto;
      padding: 0 10px;
      box-sizing: border-box;
    }
    
    .score-input-group {
      display: flex;
      flex-direction: column;
      width: 100%;
      max-width: 100px;
    }
    
    /* Diamond layout for score inputs */
    .score-inputs > div:nth-child(1) {
      grid-column: 2;
      grid-row: 3;
    }
    
    .score-inputs > div:nth-child(2) {
      grid-column: 3;
      grid-row: 2;
    }
    
    .score-inputs > div:nth-child(3) {
      grid-column: 2;
      grid-row: 1;
    }
    
    .score-inputs > div:nth-child(4) {
      grid-column: 1;
      grid-row: 2;
    }
    
    .score-input-group label {
      margin-bottom: 5px;
      font-weight: 500;
    }
    
    .score-input-group input {
      padding: 8px;
      border: 1px solid #ddd;
      border-radius: 4px;
      width: auto;
      font-size: 32px;
      text-align: center;
    }
    
    .points-display {
      color: #666;
      font-size: 12px;
      margin-top: 2px;
    }
    
    /* Statistics View */
    .statistics-view {
      display: none;
    }
    
    .stats-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
      gap: 20px;
      margin-bottom: 30px;
    }
    
    .stats-card {
      background: white;
      border: 1px solid #ddd;
      border-radius: 8px;
      padding: 20px;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    }
    
    .stats-card h3 {
      margin: 0 0 15px 0;
      color: #333;
      border-bottom: 2px solid #6f42c1;
      padding-bottom: 8px;
    }
    
    .player-stat {
      display: flex;
      justify-content: space-between;
      margin-bottom: 8px;
      padding: 4px 0;
    }
    
    .player-stat:last-child {
      margin-bottom: 0;
    }
    
    .winner {
      color: #28a745;
      font-weight: bold;
    }
    
    .modal-buttons {
      display: flex;
      justify-content: flex-end;
      gap: 10px;
    }
    
    /* History View */
    .history-view {
      display: none;
    }
    
    .view-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 20px;
    }
    
    /* Toggle Switch */
    .toggle-container {
      display: flex;
      align-items: center;
      gap: 10px;
    }
    
    .toggle-switch {
      position: relative;
      display: inline-block;
      width: 50px;
      height: 24px;
    }
    
    .toggle-switch input {
      opacity: 0;
      width: 0;
      height: 0;
    }
    
    .toggle-slider {
      position: absolute;
      cursor: pointer;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background-color: #6c757d; /* neutral gray when off */
      transition: .4s;
      border-radius: 24px;
    }
    
    .toggle-slider:before {
      position: absolute;
      content: "";
      height: 18px;
      width: 18px;
      left: 3px;
      bottom: 3px;
      background-color: white;
      transition: .4s;
      border-radius: 50%;
    }
    
    input:checked + .toggle-slider {
      background-color: #28a745;
    }
    
    input:checked + .toggle-slider:before {
      transform: translateX(26px);
    }
    
    .toggle-label {
      font-weight: 500;
      color: #333;
    }
    
    /* Players View */
    .players-view {
      display: none;
    }
    
    .players-section {
      background: white;
      border: 1px solid #ddd;
      border-radius: 8px;
      padding: 20px;
      margin-bottom: 20px;
    }
    
    .players-columns {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 20px;
      margin-bottom: 20px;
    }
    
    .players-column {
      background: white;
      border: 1px solid #ddd;
      border-radius: 8px;
      padding: 20px;
    }
    
    .players-section h3,
    .players-column h3,
    .players-column button.collapsible {
      margin: 0 0 15px 0;
      color: #333;
      border-bottom: 2px solid #fd7e14;
      padding-bottom: 8px;
    }
    
    .players-column button.collapsible {
      cursor: pointer;
      user-select: none;
      position: relative;
      background: transparent;
      border: none;
      font-size: 1.17em;
      font-weight: 600;
      color: #333;
      text-align: left;
      width: 100%;
      padding: 5px 20px 5px 0;
    }
    
    .players-section button.collapsible::after {
      content: '\25BC';
      position: absolute;
      right: 0;
      font-size: 12px;
      transition: transform 0.3s ease;
    }
    
    .players-section button.collapsible.collapsed::after {
      transform: rotate(-90deg);
    }
    
    .players-section button.collapsible:hover {
      color: #fd7e14;
    }
    
    .add-player-form.collapsed {
      display: none;
    }
    
    .add-player-form {
      display: flex;
      gap: 10px;
      align-items: stretch;
      margin-top: 10px;
    }
    
    .add-player-input {
      flex: 1;
      padding: 8px;
      border: 1px solid #ddd;
      border-radius: 4px;
      font-size: 14px;
      box-sizing: border-box;
    }
    
    .player-list {
      display: flex;
      flex-direction: column;
      gap: 10px;
      min-height: 50px;
      transition: all 0.2s ease;
    }
    
    .player-item {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 10px;
      background: #f8f9fa;
      border: 1px solid #dee2e6;
      border-radius: 4px;
    }
    
    .player-item.active {
      background: #d4edda;
      border-color: #c3e6cb;
    }
    
    .player-item.empty-seat {
      background: #f8f9fa;
      border: 2px dashed #dee2e6;
      opacity: 0.7;
    }
    
    .seat-selector {
      padding: 4px 8px;
      border: 1px solid #ddd;
      border-radius: 3px;
      font-size: 12px;
      background: white;
    }
    
    .no-queue {
      color: #999;
      font-size: 11px;
      font-style: italic;
    }
    
    .player-name-cell {
      font-weight: 500;
      position: relative;
    }
    
    .player-name-cell.empty-seat {
      color: #999;
      font-style: italic;
      background-color: #f8f9fa;
    }
    
    .game-queue-info {
      font-size: 14px;
      color: #666;
      margin: 10px 0;
      padding: 8px;
      background: #f8f9fa;
      border-radius: 4px;
      border-left: 3px solid #007acc;
    }
    
    .queue-player-cards {
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
      margin-top: 8px;
    }
    
    .queue-player-card {
      background: white;
      border: 1px solid #ddd;
      border-radius: 8px;
      padding: 8px 12px;
      font-size: 13px;
      display: flex;
      flex-direction: column;
      min-width: 120px;
      box-shadow: 0 1px 3px rgba(0,0,0,0.1);
    }
    
    .queue-player-header {
      display: flex;
      align-items: center;
      gap: 8px;
      margin-bottom: 6px;
    }
    
    .queue-order {
      background: #007acc;
      color: white;
      border-radius: 6px;
      padding: 2px 6px;
      font-size: 11px;
      font-weight: 600;
      display: inline-block;
      min-width: 12px;
      text-align: center;
      vertical-align: middle;
    }
    
    .queue-player-card.leader-queue {
      border-color: #ffd700;
      background: linear-gradient(135deg, #fff9e6 0%, #ffffff 100%);
    }
    
    .queue-player-name {
      font-weight: 600;
      color: #333;
      margin-bottom: 4px;
    }
    
    .queue-player-stats {
      display: flex;
      justify-content: space-between;
      font-size: 11px;
      color: #666;
    }
    
    .queue-no-players {
      color: #999;
      font-style: italic;
      margin-top: 8px;
    }
    
    .edit-name-input {
      width: 100%;
      padding: 2px 4px;
      font-size: 14px;
      border: 1px solid #007acc;
      border-radius: 3px;
      background: #fff;
      font-weight: 500;
    }
    
    .edit-name-input:focus {
      outline: none;
      border-color: #0056b3;
      box-shadow: 0 0 0 2px rgba(0, 123, 255, 0.25);
    }
    
    /* New Game View Styling */
    .new-game-view {
      display: none;
      padding: 20px;
    }
    
    .new-game-section {
      background: white;
      border: 1px solid #ddd;
      border-radius: 8px;
      padding: 20px;
      margin-bottom: 20px;
    }
    
    .new-game-section h3 {
      margin: 0 0 15px 0;
      color: #333;
      border-bottom: 2px solid #28a745;
      padding-bottom: 8px;
    }
    
    .section-description {
      margin-bottom: 15px;
      color: #666;
      font-size: 14px;
    }
    
    .form-group {
      margin-bottom: 15px;
    }
    
    .form-group label {
      display: block;
      margin-bottom: 5px;
      font-weight: 500;
      color: #333;
    }
    
    .form-input {
      width: 100%;
      padding: 8px 12px;
      border: 1px solid #ddd;
      border-radius: 4px;
      font-size: 14px;
      box-sizing: border-box;
    }
    
    .form-input:focus {
      outline: none;
      border-color: #28a745;
      box-shadow: 0 0 0 2px rgba(40, 167, 69, 0.25);
    }
    
    .initial-players-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
      gap: 15px;
    }
    
    .initial-player-slot label {
      font-size: 13px;
      color: #555;
      margin-bottom: 5px;
    }
    
    .new-game-actions {
      display: flex;
      gap: 10px;
      justify-content: flex-end;
    }
    
    /* Dynamic Player Input Styles */
    .players-container {
      margin-bottom: 15px;
    }
    
    .player-input-row {
      display: flex;
      align-items: center;
      margin-bottom: 10px;
      gap: 10px;
    }
    
    .player-input-row .form-input {
      flex: 1;
      margin: 0;
    }
    
    .remove-player-btn {
      background: #e74c3c;
      color: white;
      border: none;
      border-radius: 50%;
      width: 30px;
      height: 30px;
      font-size: 18px;
      font-weight: bold;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 0;
      line-height: 1;
    }
    
    .remove-player-btn:hover {
      background: #c0392b;
    }
    
    .player-controls {
      display: flex;
      flex-direction: column;
      gap: 10px;
    }
    
    /* Player Tiles Styling */
    .player-tiles-container {
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      grid-template-rows: repeat(3, auto);
      gap: 15px;
      margin: 20px auto;
      max-width: 900px;
      justify-items: center;
      align-items: center;
    }
    
    .game-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 15px;
    }
    
    .player-tile {
      background: white;
      border: 2px solid #ddd;
      border-radius: 12px;
      padding: 16px;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
      transition: all 0.3s ease;
      width: 100%;
      max-width: 250px;
    }
    
    /* Diamond layout positioning */
    #playerTile1 {
      grid-column: 2;
      grid-row: 3;
    }
    
    #playerTile2 {
      grid-column: 3;
      grid-row: 2;
    }
    
    #playerTile3 {
      grid-column: 2;
      grid-row: 1;
    }
    
    #playerTile4 {
      grid-column: 1;
      grid-row: 2;
    }
    
    .player-tile:hover {
      box-shadow: 0 4px 8px rgba(0,0,0,0.15);
      transform: translateY(-2px);
    }
    
    .player-tile.empty-seat {
      background: #f8f9fa;
      border: 2px dashed #dee2e6;
      opacity: 0.7;
    }
    
    .player-tile.leader {
      border-color: #ffd700;
      background: linear-gradient(135deg, #fff9e6 0%, #ffffff 100%);
    }
    
    .tile-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 12px;
      padding-bottom: 8px;
      border-bottom: 1px solid #eee;
    }
    
    .tile-header .player-name {
      font-weight: 600;
      font-size: 16px;
      color: #333;
    }
    
    .elim-remaining {
      color: #d9534f;
      font-size: 12px;
      margin-top: 6px;
      font-weight: 600;
      display: none;
      text-align: center;
      width: 100%;
      z-index: 2;
    }
    
    .elim-symbol {
      display: inline-block;
      margin-right: 6px;
      animation: sparkle 1.8s infinite;
      transform-origin: center center;
      font-size: 14px;
    }
    
    .player-tile.empty-seat .tile-header .player-name {
      color: #999;
      font-style: italic;
    }
    
    .leader-crown {
      font-size: 18px;
      animation: sparkle 2s infinite;
    }
    
    .last-round-winner {
      font-size: 16px;
      margin-left: 5px;
      color: #00c853;
      animation: pulse 1.5s ease-in-out infinite;
    }
    
    @keyframes sparkle {
      0%, 100% { transform: scale(1); }
      50% { transform: scale(1.2); }
    }
    
    @keyframes pulse {
      0%, 100% { opacity: 1; transform: scale(1); }
      50% { opacity: 0.7; transform: scale(1.1); }
    }
    
    .tile-stats {
      display: flex;
      flex-direction: column;
      gap: 8px;
    }
    
    .stat-item {
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    
    .stat-label {
      font-size: 13px;
      color: #666;
      font-weight: 500;
    }
    
    .stat-value {
      font-size: 16px;
      font-weight: 700;
      color: #333;
    }
    
    .player-tile.empty-seat .stat-value {
      color: #999;
    }
    
    #addRoundBtn:disabled {
      background-color: #6c757d;
      cursor: not-allowed;
      opacity: 0.6;
    }
    
    .player-name {
      font-weight: 500;
    }
    
    .player-position {
      color: #666;
      font-size: 12px;
    }
    
    .player-actions {
      display: flex;
      gap: 5px;
    }
    
    .empty-list {
      text-align: center;
      color: #666;
      font-style: italic;
      padding: 20px;
      background: #f8f9fa;
      border-radius: 4px;
      border: 1px dashed #dee2e6;
    }
    
    /* Drag and Drop Styles */
    .player-item[draggable="true"] {
      cursor: move;
      transition: transform 0.2s ease, opacity 0.2s ease, box-shadow 0.2s ease;
    }
    
    .player-item.dragging {
      opacity: 0.6;
      transform: scale(1.02);
      box-shadow: 0 8px 16px rgba(0, 0, 0, 0.2);
      z-index: 1000;
      position: relative;
    }
    
    .drag-handle {
      cursor: move;
      color: #999;
      font-size: 16px;
      padding: 0 8px;
      user-select: none;
      transition: color 0.2s ease;
    }
    
    .drag-handle:hover {
      color: #333;
    }
    
    .player-item.drag-placeholder {
      opacity: 0.3;
      border: 2px dashed #007acc;
      background: #e3f2fd;
    }
    
    /* App Header */
    .app-header {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      height: 56px;
      background: #007acc;
      color: white;
      z-index: 1002;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
      align-items: center;
      padding: 0 15px;
    }
    
    .app-header h1 {
      margin: 0;
      font-size: 20px;
      font-weight: 600;
      flex: 1;
      text-align: center;
    }
    
    /* Connection indicator in sidebar header */
    .conn-indicator {
      display: inline-block;
      margin-left: 8px;
      font-size: 12px;
      padding: 2px 6px;
      border-radius: 10px;
      color: white;
      background: #999;
      vertical-align: middle;
    }
    .conn-indicator.online { background: #28a745; }
    .conn-indicator.offline { background: #dc3545; }
    .offline-badge {
      display: inline-block;
      margin-left: 0;
      font-size: 11px;
      padding: 2px 6px;
      border-radius: 8px;
      background: #6c757d;
      color: white;
      vertical-align: middle;
    }
    .disabled-server-action {
      opacity: 0.55;
      pointer-events: none;
      filter: grayscale(30%);
    }
    /* Stack action buttons vertically on narrow/mobile screens */
    .games-management-item .game-actions { display: flex; gap: 8px; align-items: center; }
    @media (max-width: 480px) {
      .games-management-item .game-actions { flex-direction: column; align-items: stretch; }
      .games-management-item .game-actions .btn-small { width: 100%; margin-right: 0 !important; }
      .games-management-item .game-actions .offline-badge { margin-left: 0; margin-bottom: 6px; }
    }
    
    /* Sidebar header layout: space between title and connection indicator */
    .sidebar > h3 {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 8px;
      margin: 0 0 12px 0;
      position: relative;
      z-index: 1010; /* ensure header sits above close button on small screens */
    }
    .sidebar > h3 .conn-indicator { margin-left: 0; position: relative; z-index: 1011; }
    
    /* Mobile Menu Styles */
    .menu-toggle {
      background: transparent;
      color: white;
      border: none;
      padding: 10px;
      cursor: pointer;
      font-size: 24px;
      line-height: 1;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    
    .menu-toggle:hover {
      opacity: 0.8;
    }
    
    .sidebar-overlay {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0, 0, 0, 0.5);
      z-index: 1000;
      border: none;
      padding: 0;
      cursor: pointer;
    }
    
    .sidebar-close {
      display: none;
      position: absolute;
      top: 10px;
      right: 10px;
      background: transparent;
      border: none;
      font-size: 24px;
      cursor: pointer;
      color: #666;
      padding: 5px 10px;
      z-index: 1009; /* keep under header elements like connection indicator */
    }
    
    .sidebar-close:hover {
      color: #333;
    }
    
    /* Mobile Responsive Styles */
    @media (max-width: 768px) {
      body {
        overflow-x: hidden;
      }
      
      .app-header {
        display: flex;
      }
      
      .main-content {
        padding-top: 71px;
        padding-left: 15px;
        padding-right: 15px;
      }
      
      .sidebar {
        position: fixed;
        top: 56px; /* sit below the fixed app header */
        left: 0;
        bottom: 0;
        height: calc(100% - 56px);
        transform: translateX(-100%);
        box-shadow: 2px 0 8px rgba(0, 0, 0, 0.2);
      }
      
      .sidebar.open {
        transform: translateX(0);
      }
      
      /* On desktop, hide bottom game buttons only when sidebar is visible */
      @media (min-width: 769px) {
        body.sidebar-visible .game-secondary-menu-btn {
          display: none !important;
        }
      }
      
      .sidebar-overlay.active {
        display: block;
      }
      
      .sidebar-close {
        display: block;
      }
      
      .player-tiles-container {
        gap: 10px;
        max-width: 100%;
        margin: 20px 10px;
      }
      
      .player-tile {
        max-width: 180px;
        padding: 12px;
        font-size: 14px;
      }
      
      /* Keep diamond layout on mobile */
      
      .players-columns {
        grid-template-columns: 1fr;
      }
      
      .score-inputs {
        gap: 10px;
        max-width: 100%;
      }
      
      .score-input-group {
        max-width: 100px;
      }
      
      .modal-content {
        width: 95%;
        /* push modal lower to avoid fixed mobile header overlapping */
        margin: calc(5% + 72px) auto 5% auto;
        margin-left: auto;
        transform: none;
      }
      
      .history-table {
        font-size: 12px;
      }
      
      .history-table th,
      .history-table td {
        padding: 4px;
      }
    }
    
    @media (max-width: 480px) {
      .view-header {
        flex-direction: column;
        align-items: flex-start;
        gap: 10px;
      }
      
      .view-header > div {
        width: 100%;
      }
    }
  </style>
</head>
<body>
  
  <div class="app-header">
    <button class="menu-toggle" onclick="toggleSidebar()" aria-label="Toggle menu">‚ò∞</button>
    <h1>ScoreBoard</h1>
    <div style="width: 44px;"></div><!-- Spacer for centering -->
  </div>
  
  <button class="sidebar-overlay" onclick="closeSidebar()" aria-label="Close sidebar"></button>
  
  <div class="sidebar">
    <button class="sidebar-close" onclick="closeSidebar()" aria-label="Close menu">&times;</button>
    <h3>ScoreBoard <span id="connectionIndicator" class="conn-indicator offline" aria-live="polite">Offline</span></h3>
    
    <div class="navigation">
      <h4 style="margin-bottom: 10px; color: #666;">Navigation</h4>
      <button class="sidebar-btn bg-green" onclick="showGame()">Game</button>
      <button class="sidebar-btn bg-orange" onclick="showPlayers()">Players</button>
      <button class="sidebar-btn bg-purple" onclick="showStatistics()">Statistics</button>
      <button class="sidebar-btn bg-blue" onclick="showHistory()">History</button>
    </div>
    
    <hr style="margin: 20px 0; border: none; border-top: 1px solid #ddd;">
    
    <h4 style="margin-bottom: 10px; color: #666;">Games</h4>
    <button class="sidebar-btn bg-green" onclick="showNewGame()">Create New Game</button>
    <button class="sidebar-btn bg-red" onclick="showGamesManagement()">Manage Games</button>
    
    <div class="game-list" id="gameList">
      <!-- Games will be populated here -->
    </div>
  </div>
  
  <div class="main-content">
    <!-- Main Game View -->
    <div id="gameView">
      <div class="game-header">
        <h2 id="gameTitle">Score Sheet</h2>
        <button id="addRoundBtn" class="btn-large bg-green" onclick="showAddRoundModal()">‚ñ∂Ô∏è Round</button>
      </div>
      
      <div id="playerTiles" class="player-tiles-container">
        <div class="player-tile" id="playerTile1">
          <div class="tile-header">
            <span class="player-name">Player 1</span>
            <span class="leader-crown" style="display: none;">üëë</span>
            <span class="last-round-winner" style="display: none;">‚ñ∂Ô∏è</span>
          </div>
          <div class="tile-stats">
            <div class="stat-item">
              <span class="stat-label">Total Score</span>
              <span class="stat-value" id="tileTotal1">0</span>
            </div>
            <div class="stat-item">
              <span class="stat-label">Avg Score</span>
              <span class="stat-value" id="tileAvg1">0</span>
            </div>
            <div class="stat-item">
              <span class="stat-label">Rounds</span>
              <span class="stat-value" id="tileRounds1">0</span>
            </div>
          </div>
        </div>
        
        <div class="player-tile" id="playerTile2">
          <div class="tile-header">
            <span class="player-name">Player 2</span>
            <span class="leader-crown" style="display: none;">üëë</span>
            <span class="last-round-winner" style="display: none;">‚ñ∂Ô∏è</span>
          </div>
          <div class="tile-stats">
            <div class="stat-item">
              <span class="stat-label">Total Score</span>
              <span class="stat-value" id="tileTotal2">0</span>
            </div>
            <div class="stat-item">
              <span class="stat-label">Avg Score</span>
              <span class="stat-value" id="tileAvg2">0</span>
            </div>
            <div class="stat-item">
              <span class="stat-label">Rounds</span>
              <span class="stat-value" id="tileRounds2">0</span>
            </div>
          </div>
        </div>
        
        <div class="player-tile" id="playerTile3">
          <div class="tile-header">
            <span class="player-name">Player 3</span>
            <span class="leader-crown" style="display: none;">üëë</span>
            <span class="last-round-winner" style="display: none;">‚ñ∂Ô∏è</span>
          </div>
          <div class="tile-stats">
            <div class="stat-item">
              <span class="stat-label">Total Score</span>
              <span class="stat-value" id="tileTotal3">0</span>
            </div>
            <div class="stat-item">
              <span class="stat-label">Avg Score</span>
              <span class="stat-value" id="tileAvg3">0</span>
            </div>
            <div class="stat-item">
              <span class="stat-label">Rounds</span>
              <span class="stat-value" id="tileRounds3">0</span>
            </div>
          </div>
        </div>
        
        <div class="player-tile" id="playerTile4">
          <div class="tile-header">
            <span class="player-name">Player 4</span>
            <span class="leader-crown" style="display: none;">üëë</span>
            <span class="last-round-winner" style="display: none;">‚ñ∂Ô∏è</span>
          </div>
          <div class="tile-stats">
            <div class="stat-item">
              <span class="stat-label">Total Score</span>
              <span class="stat-value" id="tileTotal4">0</span>
            </div>
            <div class="stat-item">
              <span class="stat-label">Avg Score</span>
              <span class="stat-value" id="tileAvg4">0</span>
            </div>
            <div class="stat-item">
              <span class="stat-label">Rounds</span>
              <span class="stat-value" id="tileRounds4">0</span>
            </div>
          </div>
        </div>
      </div>
      
      
      <div id="gameQueueInfo" class="game-queue-info">
        <strong>Player Queue:</strong>
        <div id="queuePlayerCards" class="queue-player-cards">
          <!-- Queue player cards will be populated here -->
        </div>
      </div>
      
      <div style="margin-top: 20px; text-align: center; display: flex; gap: 10px; justify-content: center; flex-wrap: wrap;">
        <button class="game-secondary-menu-btn btn-large bg-orange" onclick="showPlayers()">Manage Players</button>
        <button class="game-secondary-menu-btn btn-large bg-purple" onclick="showStatistics()">Statistics</button>
        <button class="game-secondary-menu-btn btn-large bg-blue" onclick="showHistory()">History</button>
      </div>
    </div>
    
    <!-- No Games View (shown when there are no games) -->
    <div id="noGamesView" style="display:none; padding: 40px; text-align:center;">
      <h2>No games</h2>
      <p style="color:#666; max-width:600px; margin: 0 auto 16px;">There are no games saved. Create a new game to get started.</p>
      <button class="btn-large bg-blue" onclick="showNewGame()">Create New Game</button>
    </div>
    
    <!-- History View -->
    <div id="historyView" class="history-view">
      <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
        <h2 id="historyTitle" style="margin: 0;">Game History</h2>
        <button class="btn-large bg-blue" onclick="showGame()">‚è™ Game</button>
      </div>
      
      <div style="display: flex; justify-content: center; align-items: center; margin-bottom: 15px;">
        <div class="toggle-container">
          <span class="toggle-label">Points</span>
          <label class="toggle-switch">
            <input type="checkbox" id="showCardsToggle" checked onchange="toggleHistoryView()" aria-label="Toggle between points and cards view">
            <span class="toggle-slider"></span>
          </label>
          <span class="toggle-label">Cards</span>
        </div>
      </div>
      
      <p id="historyDescription" style="font-weight: 500; margin-bottom: 15px; color: #666;">Showing: Cards left per round</p>
      
      <div class="table-scroll-wrapper">
        <table class="history-table">
          <thead>
            <tr id="historyTableHeader">
              <th>Round</th>
              <!-- Additional player headers will be populated dynamically -->
            </tr>
          </thead>
          <tbody id="historyTableBody">
            <!-- History rounds will be populated here -->
          </tbody>
        </table>
      </div>
      
      <div style="margin-top: 15px; text-align: center;">
        <button onclick="deleteLastRound()" class="btn-small" style="background: #dc3545; color: white; padding: 8px 16px; font-size: 14px;">Delete Last Round</button>
      </div>
      
      <div style="background: #f8f9fa; padding: 15px; border-radius: 8px; margin-top: 20px; border-left: 4px solid #6f42c1;">
        <h3 style="margin-top: 0; margin-bottom: 10px; color: #6f42c1;">Color Legend</h3>
        <div style="display: flex; flex-wrap: wrap; gap: 12px; justify-content: center; font-size: 13px;">
          <div style="display: flex; align-items: center; gap: 5px;">
            <span style="display: inline-block; width: 20px; height: 20px; background: #90ee90; border: 1px solid #ddd; border-radius: 3px;"></span>
            <span>Winner</span>
          </div>
          <div style="display: flex; align-items: center; gap: 5px;">
            <span style="display: inline-block; width: 20px; height: 20px; background: #ffffff; border: 1px solid #ddd; border-radius: 3px;"></span>
            <span>1-7 cards</span>
          </div>
          <div style="display: flex; align-items: center; gap: 5px;">
            <span style="display: inline-block; width: 20px; height: 20px; background: #ffcccc; border: 1px solid #ddd; border-radius: 3px;"></span>
            <span>8-9 cards</span>
          </div>
          <div style="display: flex; align-items: center; gap: 5px;">
            <span style="display: inline-block; width: 20px; height: 20px; background: #ff9999; border: 1px solid #ddd; border-radius: 3px;"></span>
            <span>10-12 cards</span>
          </div>
          <div style="display: flex; align-items: center; gap: 5px;">
            <span style="display: inline-block; width: 20px; height: 20px; background: #ff6666; border: 1px solid #ddd; border-radius: 3px;"></span>
            <span>13+ cards</span>
          </div>
        </div>
      </div>
    </div>
    
    <div id="gamesManagementView" class="games-management-view" style="display: none;">
      <div class="view-header">
        <h2>Games Management</h2>
      </div>
      
      <p style="font-weight: 500; margin-bottom: 15px; color: #666;">Manage all your games. Click on a game to switch to it, or delete games you no longer need.</p>
      
      <div id="gamesManagementList" class="games-management-list">
        <!-- Games will be populated here -->
      </div>
    </div>
    
    <!-- Statistics View -->
    <div id="statisticsView" class="statistics-view">
      <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
        <h2 id="statisticsTitle" style="margin: 0;">Game Statistics</h2>
        <button class="btn-large bg-blue" onclick="showGame()">‚è™ Game</button>
      </div>
      
      <div style="margin-bottom: 20px; display:flex; gap:18px; align-items:center;">
        <p style="margin:0;"><strong>Total Rounds:</strong> <span id="totalRounds">0</span></p>
        <!-- leader text intentionally omitted -->
      </div>
      
      <div class="table-scroll-wrapper">
        <table class="statistics-table" style="min-width: 720px; width: 100%;">
          <thead>
            <tr>
              <th>Player</th>
              <th>Score</th>
              <th>Avg Score</th>
              <th>Rounds</th>
              <th>Wins</th>
              <th>Win Rate</th>
              <th>Avg Cards</th>
              <th>Points Made</th>
            </tr>
          </thead>
          <tbody id="statisticsTableBody">
            <!-- Statistics will be populated here -->
          </tbody>
        </table>
      </div>
      
      <div style="background: #f8f9fa; padding: 15px; border-radius: 8px; margin-top: 20px; border-left: 4px solid #6f42c1;">
        <h3 style="margin-top: 0; margin-bottom: 10px; color: #6f42c1;">Statistics Explanation</h3>
        <p style="margin: 5px 0; font-size: 13px;"><strong>Leader:</strong> Player(s) with the lowest average score. If tied, the player with the most rounds played is the leader.</p>
        <p style="margin: 5px 0; font-size: 13px;"><strong>Score:</strong> Accumulated points across all rounds played</p>
        <p style="margin: 5px 0; font-size: 13px;"><strong>Avg Score:</strong> Average points per round (lower is better)</p>
        <p style="margin: 5px 0; font-size: 13px;"><strong>Win Rate:</strong> Percentage of rounds won</p>
        <p style="margin: 5px 0; font-size: 13px;"><strong>Avg Cards:</strong> Average number of cards left per round</p>
        <p style="margin: 5px 0; font-size: 13px;"><strong>Points Made:</strong> Total points scored by other players when this player won</p>
      </div>
    </div>
    
    <!-- Players View -->
    <div id="playersView" class="players-view">
      <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
        <h2 id="playersTitle" style="margin: 0;">Player Management</h2>
        <div style="display:flex; gap:8px; align-items:center;">
          <button class="btn-large bg-blue" onclick="showGame()">‚è™ Game</button>
        </div>
      </div>
      
      
      
      <div class="players-column players-section" style="margin-bottom: 20px;">
        <button class="collapsible collapsed" onclick="toggleAddPlayerForm()">‚ûï Add New Player</button>
        <div class="add-player-form collapsed">
          <input type="text" class="add-player-input" placeholder="Enter player name..." id="newPlayerInput">
          <button class="btn-large bg-green" onclick="addPlayer()">Add Player</button>
        </div>
      </div>
      
      <div class="players-columns">
        <div class="players-column">
          <h3>Active Players</h3>
          <div class="player-list" id="activePlayersList">
            <!-- Active players will be populated here -->
          </div>
        </div>
        
        <div class="players-column">
          <h3>Player Queue</h3>
          <div class="player-list" id="queuePlayersList">
            <!-- Queued players will be populated here -->
          </div>
        </div>
      </div>
      <div style="background: #f8f9fa; padding: 15px; border-radius: 8px; margin-top: 20px; border-left: 4px solid #6f42c1;">
        <h3 style="margin-top: 0; margin-bottom: 10px; color: #6f42c1;">Elimination rules</h3>
        <div style="margin: 5px 0; font-size: 13px; line-height:1.4; color:#333;">
          <p style="margin:0 0 6px 0;"><strong>Thresholds:</strong> One-time 25-point threshold, and thereafter eliminations happen at 50-point multiples (50, 100, 150, ‚Ä¶).</p>
          <p style="margin:0 0 6px 0;"><strong>How it works:</strong> When a player's total reaches or exceeds a threshold they become an elimination candidate and ‚Äî if a replacement is available ‚Äî are removed from active play and moved to the end of the <em>Player Queue</em>, while the next queued player fills their seat.</p>
          <p style="margin:0 0 6px 0;"><strong>Tie-breaking:</strong> If multiple players cross a threshold in the same round, the candidate with the largest overshoot beyond the threshold is chosen. If overshoots are equal, the player with the higher previous total is chosen. If still tied, the left-to-right seat order (Player 1 ‚Üí Player 4) is used.</p>
          <p style="margin:0;"><strong>No replacement available:</strong> If the queue is empty the elimination is skipped.</p>
        </div>
      </div>
    </div>
    
    <!-- New Game View -->
    <div id="newGameView" class="new-game-view">
      <h2>Create New Game</h2>
      
      <div class="new-game-section">
        <h3>Game Details</h3>
        <div class="form-group">
          <label for="newGameNameInput">Game Name:</label>
          <input type="text" id="newGameNameInput" placeholder="Enter game name..." class="form-input">
          <div style="margin-top:8px; display:flex; align-items:center; gap:8px;">
            <label class="toggle-switch" title="Create locally (do not sync to server)" style="margin-right:8px;">
              <input type="checkbox" id="createLocalToggle" aria-label="Create locally (do not sync to server)" />
              <span class="toggle-slider"></span>
            </label>
            <label for="createLocalToggle" style="margin:0; font-size:13px; color:#333;">Create locally (do not sync to server)</label>
          </div>
        </div>
      </div>
      
      <div class="new-game-section">
        <h3>Initial Players</h3>
        <p class="section-description">Add players for this game. First 4 players will start active, additional players will be queued.</p>
        
        <div id="playersContainer" class="players-container">
          <div class="player-input-row">
            <input type="text" class="form-input player-name-input" placeholder="Player 1 Name">
            <button type="button" class="remove-player-btn" onclick="removePlayerInput(this)" style="display: none;">√ó</button>
          </div>
          <div class="player-input-row">
            <input type="text" class="form-input player-name-input" placeholder="Player 2 Name">
            <button type="button" class="remove-player-btn" onclick="removePlayerInput(this)" style="display: none;">√ó</button>
          </div>
          <div class="player-input-row">
            <input type="text" class="form-input player-name-input" placeholder="Player 3 Name">
            <button type="button" class="remove-player-btn" onclick="removePlayerInput(this)" style="display: none;">√ó</button>
          </div>
          <div class="player-input-row">
            <input type="text" class="form-input player-name-input" placeholder="Player 4 Name">
            <button type="button" class="remove-player-btn" onclick="removePlayerInput(this)" style="display: none;">√ó</button>
          </div>
        </div>
        
        <div class="player-controls">
          <button type="button" class="btn-large bg-green" onclick="addPlayerInput()">+ Add Player</button>
        </div>
      </div>
      
      <div class="new-game-actions">
        <button onclick="clearNewGameInputs()" class="btn-large bg-grey">Clear</button>
        <button onclick="createNewGameWithPlayers()" class="btn-large bg-blue">Create Game</button>
      </div>
    </div>
    
    <!-- Add Round Modal -->
    <div id="addRoundModal" class="modal">
      <div class="modal-content">
        <div id="addRoundOverlay" style="position:absolute; inset:0; background:rgba(255,255,255,0.82); z-index:60; display:flex; align-items:center; justify-content:center;">
          <div style="display:flex; align-items:center; gap:10px; padding:8px 12px; border-radius:6px; background:rgba(255,255,255,0.95); box-shadow:0 2px 6px rgba(0,0,0,0.12);">
            <svg width="20" height="20" viewBox="0 0 50 50" xmlns="http://www.w3.org/2000/svg" aria-hidden="true">
              <circle cx="25" cy="25" r="20" stroke="#007bff" stroke-width="4" fill="none" stroke-linecap="round" stroke-dasharray="31.4 31.4">
                <animateTransform attributeName="transform" type="rotate" dur="1s" repeatCount="indefinite" from="0 25 25" to="360 25 25" />
              </circle>
            </svg>
            <strong style="color:#007bff; font-size:14px;">Saving‚Ä¶</strong>
          </div>
        </div>
        <div class="modal-header">
          <h3>Enter Cards Left</h3>
          <button type="button" class="close" onclick="closeAddRoundModal()" aria-label="Close modal">&times;</button>
        </div>
        
        <div class="score-inputs">
          <div class="score-input-group">
            <label for="p1Score">Player 1 Cards:</label>
            <input type="number" id="p1Score" min="0" oninput="updatePointsDisplay()">
            <small class="points-display" id="p1Points">Points: 0</small>
          </div>
          <div class="score-input-group">
            <label for="p2Score">Player 2 Cards:</label>
            <input type="number" id="p2Score" min="0" oninput="updatePointsDisplay()">
            <small class="points-display" id="p2Points">Points: 0</small>
          </div>
          <div class="score-input-group">
            <label for="p3Score">Player 3 Cards:</label>
            <input type="number" id="p3Score" min="0" oninput="updatePointsDisplay()">
            <small class="points-display" id="p3Points">Points: 0</small>
          </div>
          <div class="score-input-group">
            <label for="p4Score">Player 4 Cards:</label>
            <input type="number" id="p4Score" min="0" oninput="updatePointsDisplay()">
            <small class="points-display" id="p4Points">Points: 0</small>
          </div>
        </div>
        
        <div class="modal-buttons">
          <button class="btn-large bg-grey" onclick="closeAddRoundModal()">Cancel</button>
          <button id="confirmRoundBtn" class="btn-large bg-blue" onclick="confirmRound()">Add Round</button>
        </div>
      </div>
    </div>
    
    <!-- Replacement Modal -->
    <div id="replacementModal" class="modal">
      <div class="modal-content">
        <div class="modal-header">
          <h3><span class="alert-icon" aria-hidden="true">‚ö†Ô∏è</span>Replacements</h3>
          <button type="button" class="close" onclick="closeReplacementModal()" aria-label="Close modal">&times;</button>
        </div>
        <div id="replacementList" class="replacement-list" style="margin: 6px 0;"></div>
        <div style="text-align: right; margin-top: 8px;">
          <button class="btn-large bg-grey" onclick="closeReplacementModal()">Close</button>
        </div>
      </div>
    </div>
    
    <!-- Generic Edit Modal (reusable for player or game names) -->
    <div id="genericEditModal" class="modal" style="display:none;">
      <div class="modal-content">
        <div class="modal-header">
          <h3 id="genericEditTitle">Edit</h3>
          <button type="button" class="close" onclick="cancelGenericEditModal()" aria-label="Close modal">&times;</button>
        </div>
        <div style="margin-bottom:12px;">
          <label id="genericEditLabel" for="genericEditInput">Value:</label>
          <input type="text" id="genericEditInput" class="form-input" maxlength="120" style="margin-top:6px; width:100%; box-sizing:border-box;" onkeypress="if(event.key==='Enter'){confirmGenericEditModal();} else if(event.key==='Escape'){cancelGenericEditModal();}">
        </div>
        <div style="text-align:right; margin-top:8px;">
          <button class="btn-large bg-grey" onclick="cancelGenericEditModal()">Cancel</button>
          <button class="btn-large bg-blue" onclick="confirmGenericEditModal()">Save</button>
        </div>
      </div>
    </div>
    
    <script type="module">
      const GAMES_STORAGE_KEY = "cardgame-games";
      
      // Offline/localStorage keys are kept for migration only
      let games = {};
      // Per-game client-only metadata that must NOT be written to the server
      // e.g. round counts for metadata-only server responses and whether
      // the full `rounds` have been loaded for a given game id.
      let games_metadata = {};
      let currentGameId = localStorage.getItem("cardgame-current-game") || null;
      // API base URL: priority -> URL query `?api=...` -> global `globalThis.API_BASE` -> current origin -> fallback localhost:3000
      const API_BASE = (function(){
        const params = new URLSearchParams(location.search || '');
        if (params.get('api')) return params.get('api').replace(/\/$/, '');
        if (globalThis.API_BASE) return String(globalThis.API_BASE).replace(/\/$/, '');
        if (location.protocol && location.protocol.startsWith('http')) {
          return `${location.protocol}//${location.hostname}${location.port ? ':'+location.port : ''}`.replace(/\/$/, '');
        }
        return 'http://localhost:3000';
      })();
      let rounds = [];
      // track whether backend is reachable
      let serverAvailable = false;
      let totals = [0, 0, 0, 0];
      // Players will be loaded per-game, not globally
      let players = {"active": ["Player 1", "Player 2", "Player 3", "Player 4"], "queue": []};
      // Track how many 50-point levels each player has reached
      let eliminationLevels = {};
      // Which player (name) caused the one-time 25-point elimination; null if unused
      let elimination25UsedBy = null;
      // Internal flag to prevent duplicate alerts when onblur triggers savePlayerName again
      let _suppressDuplicateAlert = false;
      // Last replacements captured for modal display
      let lastReplacements = [];
      
      // Allow tests and external scripts to set the module-scoped currentGameId
      function setCurrentGameId(id) {
        currentGameId = id || null;
        try {
          if (currentGameId) localStorage.setItem('cardgame-current-game', currentGameId);
          else localStorage.removeItem('cardgame-current-game');
        } catch (e) { console.warn('setCurrentGameId: localStorage update failed', e); }
        
        if (typeof loadCurrentGame === 'function') loadCurrentGame();
        if (typeof renderGameList === 'function') renderGameList();
      }
      globalThis.setCurrentGameId = setCurrentGameId;
      
      // Tests: allow syncing an array into the module-scoped `rounds` in-place
      function syncRoundsToModule(arr) {
        if (!Array.isArray(arr)) return;
        rounds.length = 0;
        arr.forEach(r => rounds.push(r));
        // globalThis.rounds is a reference, if already exposed we don't need to re-expose
        globalThis.rounds = rounds;
      }
      globalThis.syncRoundsToModule = syncRoundsToModule;
      
      function setElimination25UsedBy(name) {
        elimination25UsedBy = name || null;
        globalThis.elimination25UsedBy = elimination25UsedBy;
      }
      globalThis.setElimination25UsedBy = setElimination25UsedBy;
      
      function toggleAddPlayerForm() {
        const header = document.querySelector('.players-column button.collapsible');
        const form = document.querySelector('.add-player-form');
        
        header.classList.toggle('collapsed');
        form.classList.toggle('collapsed');
        
        // Focus input when expanding
        if (!form.classList.contains('collapsed')) {
          const input = document.getElementById('newPlayerInput');
          if (input) {
            setTimeout(() => input.focus(), 100);
          }
        }
      }
      
      // Helper: compute total players for a game (prefers explicit players arrays, falls back to metadata)
      function getTotalPlayers(game) {
        if (game && game.players && (Array.isArray(game.players.active) || Array.isArray(game.players.queue))) {
          const activeLen = Array.isArray(game.players.active) ? game.players.active.length : 0;
          const queueLen = Array.isArray(game.players.queue) ? game.players.queue.length : 0;
          return activeLen + queueLen;
        }
        if (game && Array.isArray(game.playerCreationOrder)) return game.playerCreationOrder.length;
        return 0;
      }
      globalThis.getTotalPlayers = getTotalPlayers;
      
      // Helper: compute total rounds for a game (prefers explicit `rounds` array, falls back to `roundCount` metadata)
      function getTotalRounds(game) {
        if (!game) return 0;
        // Find the game id corresponding to this game object (if present)
        let foundId = null;
        try {
          for (const id in games) {
            if (games[id] === game) { foundId = id; break; }
          }
        } catch (e) { console.warn('getTotalRounds: failed to find game id', e); }

        // If the client has loaded the full rounds for this game (tracked in games_metadata), prefer that
        if (Array.isArray(game.rounds) && foundId && games_metadata && games_metadata[foundId] && games_metadata[foundId].roundsLoaded) {
          return game.rounds.length;
        }
        
        // Otherwise consult client-only metadata for a server-provided round count
        if (foundId && games_metadata && games_metadata[foundId] && typeof games_metadata[foundId].roundCount === 'number') {
          return games_metadata[foundId].roundCount;
        }

        return 0;
      }
      
      // Realtime: WebSocket-based updates
      // Connects to server WebSocket endpoint and refreshes data when notified.
      (function(){
        let _ws = null;
        let _reconnectDelay = 1000;
        const _maxDelay = 60000;
        
        function _wsUrl() {
          // Map API_BASE (http/https) to ws/wss and append '/ws' endpoint
          if (!API_BASE) return null;
          if (typeof API_BASE !== 'string') return null;
          return API_BASE.replace(/^http/, 'ws') + '/ws';
        }
        
        function handleMessage(payload) {
          if (!payload) return;
          // Generic 'games-updated' -> refresh metadata list
          if (payload.type === 'games-updated') {
            // debounce repeated events
            if (globalThis._realtimeScheduled) return;
            globalThis._realtimeScheduled = setTimeout(() => { globalThis._realtimeScheduled = null; initializeGames(); }, 250);
            return;
          }
          // Single-game update: fetch the canonical record and merge
          if (payload.type === 'game-updated' && payload.id) {
            fetch(API_BASE + '/api/games/' + encodeURIComponent(payload.id))
            .then(r => r && r.ok ? r.json() : null)
            .then(res => {
              if (!res || !res.data) return;
              const sid = res.id || payload.id;
              games[sid] = res.data || games[sid] || {};
              games[sid].name = res.name || games[sid].name;
              games_metadata[sid] = games_metadata[sid] || {};
              games_metadata[sid].roundsLoaded = true;
              games_metadata[sid].roundCount = (games[sid].rounds || []).length;
              persistLocalGames();
              renderGameList();
              renderGamesManagement();
              if (currentGameId === sid) {
                loadCurrentGame();
                updateGameDisplay();
              }
            }).catch(err => { console.warn('fetch game for update failed', err); });
          }
        }
        
        function connect() {
          if (!serverAvailable) return;
          const url = _wsUrl();
          if (!url) return;
          
          if (_ws && (_ws.readyState === WebSocket.OPEN || _ws.readyState === WebSocket.CONNECTING)) return;
          
          try {
            _ws = new WebSocket(url);
            globalThis._realtimeSocket = _ws;
            _ws.onopen = () => { console.log('Realtime WS connected'); _reconnectDelay = 1000; };
            _ws.onmessage = (ev) => {
              try { const payload = JSON.parse(ev.data); handleMessage(payload); } catch (e) { console.warn('WS handling failed', e); }
            };
            _ws.onclose = () => { console.warn('Realtime WS closed, reconnecting...'); globalThis._realtimeSocket = null; setTimeout(connect, _reconnectDelay); _reconnectDelay = Math.min(_maxDelay, _reconnectDelay * 2); };
            _ws.onerror = (e) => { 
                console.warn('Realtime WS error', e); 
                if (_ws) _ws.close(); 
            };
          } catch (e) {
            console.warn('Realtime WS init failed', e);
            setTimeout(connect, _reconnectDelay);
            _reconnectDelay = Math.min(_maxDelay, _reconnectDelay * 2);
          }
        }
        
        function disconnect() {
          if (_ws) {
            _ws.onclose = null;
            _ws.close();
            _ws = null;
            globalThis._realtimeSocket = null;
          }
        }
        
        // Public helpers
        globalThis.initRealtimeWebSocket = function() { connect(); };
        globalThis.stopRealtimeWebSocket = function() { disconnect(); };
      })();
      
      // Update UI and document title to reflect connection state
      const _baseTitle = (document && document.title) ? document.title.replaceAll(/\s*\(Online\)|\s*\(Offline\)/g, '') : 'ScoreBoard';
      function updateConnectionIndicator() {
        const el = document.getElementById('connectionIndicator');
        if (el) {
          el.textContent = serverAvailable ? 'Online' : 'Offline';
          el.classList.toggle('online', serverAvailable);
          el.classList.toggle('offline', !serverAvailable);
        }
        if (document) {
          document.title = _baseTitle + (serverAvailable ? ' (Online)' : ' (Offline)');
        }
        // Update server-action UI states when connection changes
        if (typeof updateServerActionStates === 'function') {
           updateServerActionStates();
        }
      }
      
      // Helper to set module-scoped `serverAvailable` from external scripts/tests
      function setServerAvailable(v) {
        serverAvailable = !!v;
        updateConnectionIndicator();
      }
      
      // initialize indicator
      updateConnectionIndicator();
      
      function testServerConnection(timeout = 3000) {
        return new Promise(resolve => {
          const timer = setTimeout(() => {
            serverAvailable = false;
            resolve(false);
          }, timeout);
          
          fetch(API_BASE + '/health').then(r => {
            clearTimeout(timer);
            serverAvailable = !!(r && r.ok);
            updateConnectionIndicator();
            resolve(serverAvailable);
          }).catch(() => {
            clearTimeout(timer);
            serverAvailable = false;
            updateConnectionIndicator();
            resolve(false);
          });
        });
      }
      
      function persistLocalGames() {
        try {
          localStorage.setItem(GAMES_STORAGE_KEY, JSON.stringify(games));
        } catch (e) {
          console.warn('persistLocalGames failed', e);
        }
      }
      
      // Safely load stored games from localStorage. Returns an object (possibly empty)
      // and never throws. Malformed JSON or non-object values are handled gracefully
      // and logged to the console for debugging.
      function safeLoadStoredGames() {
        try {
          const raw = localStorage.getItem(GAMES_STORAGE_KEY);
          if (!raw) return {};
          const parsed = JSON.parse(raw);
          if (parsed && typeof parsed === 'object') {
            return parsed.games && typeof parsed.games === 'object' ? parsed.games : parsed;
          }
          console.warn('safeLoadStoredGames: stored value is not an object', parsed);
          return {};
        } catch (e) {
          console.warn('safeLoadStoredGames: failed parsing stored games', e);
          return {};
        }
      }
      
      function updateServerActionStates() {
        const els = document.querySelectorAll('[data-server-action]');
        els.forEach(el => {
          if (serverAvailable) {
            el.removeAttribute('disabled');
            el.classList.remove('disabled-server-action');
            el.title = el.dataset.serverTitle || '';
          } else {
            el.setAttribute('disabled', 'disabled');
            el.classList.add('disabled-server-action');
            // keep existing title if provided, otherwise set a default
            el.dataset.serverTitle = el.title || 'Requires server connection';
            el.title = 'Requires server connection';
          }
        });
      }
      
      // Attempt to sync a local-only game to the server. On success remove the
      // game's backup from localStorage so it's no longer treated as local-only.
      async function syncLocalGameToServer(gameId) {
        if (!games[gameId]) {
          alert('Game not found');
          return;
        }
        if (!serverAvailable) {
          alert('Server not available ‚Äî cannot sync now');
          return;
        }
        const game = games[gameId];
        if (!game.localOnly) {
          alert('This game is already stored on the server');
          return;
        }
        
        try {
          // Do not send the localOnly flag to the server - remove it from payload
          const dataToSend = { ...game };
          if (dataToSend.localOnly !== undefined) delete dataToSend.localOnly;
          const payload = { id: gameId, name: game.name || (`Game ${gameId}`), data: dataToSend };
          const resp = await fetch(API_BASE + '/api/games', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(payload)
          });
          if (!resp.ok) throw new Error('Server responded ' + resp.status);
          
          // Fetch canonical server record for this game to ensure we reflect server state
          try {
            const gresp = await fetch(API_BASE + '/api/games/' + encodeURIComponent(gameId));
            if (gresp.ok) {
              const gjson = await gresp.json();
              // Server may wrap data in { id, name, data }
              const serverData = gjson && gjson.data ? gjson.data : gjson;
              // Merge into local memory but preserve any client-only transient fields we want
              games[gameId] = serverData || game;
              games_metadata[gameId] = games_metadata[gameId] || {};
              games_metadata[gameId].localOnly = false;
            } else {
              throw new Error('Canonical fetch failed');
            }
          } catch (e) {
            // If fetching canonical record failed, at least mark as non-local locally
            console.warn('Canonical record fetch incomplete', e);
            game.localOnly = false;
            games[gameId] = game;
            games_metadata[gameId] = games_metadata[gameId] || {};
            games_metadata[gameId].localOnly = false;
          }
          
          // Persist current in-memory state and refresh UI
          persistLocalGames();
          renderGameList();
          renderGamesManagement();
          alert('Game synced to server successfully');
        } catch (err) {
          console.warn('syncLocalGameToServer failed', err);
          alert('Sync failed: ' + (err && err.message ? err.message : 'unknown error'));
        }
      }
      
      function addPlayer() {
        const input = document.getElementById("newPlayerInput");
        const name = input.value.trim();
        
        if (!name) {
          alert("Please enter a player name");
          return;
        }
        
        // Check if player already exists
        const allPlayers = [...players.active, ...players.queue];
        if (allPlayers.includes(name)) {
          alert("Player name already exists");
          return;
        }
        
        // If less than 4 active players, add to active, otherwise add to queue
        if (players.active.length < 4) {
          players.active.push(name);
        } else {
          players.queue.push(name);
        }
        // Record creation order for current game
        if (currentGameId && games[currentGameId]) {
          games[currentGameId].playerCreationOrder = games[currentGameId].playerCreationOrder || [];
          if (!games[currentGameId].playerCreationOrder.includes(name)) {
            games[currentGameId].playerCreationOrder.push(name);
          }
        }
        
        input.value = "";
        saveCurrentGame();
        renderPlayers();
        updateGameDisplay();
      }
      
      function demotePlayer(playerName) {
        const activeIndex = players.active.indexOf(playerName);
        if (activeIndex > -1) {
          players.active[activeIndex] = null; // Leave empty seat
          players.queue.push(playerName);
          saveCurrentGame();
          renderPlayers();
          updateGameDisplay();
        }
      }
      
      function editPlayerName(currentName, playerType, index) {
        // Open generic modal to edit player name
        try {
          openGenericEditModal('player', { playerType: playerType, index: index, originalName: currentName || '' });
        } catch (e) { console.warn('editPlayerName: failed to open modal', e); }
      }
            
      function cancelEditPlayerName(originalName, playerType, index) {
        renderPlayers();
      }
      
      // Rename a player across game state: playerCreationOrder, rounds, eliminationLevels, lastReplacements
      function renamePlayerAcrossGame(originalName, newName) {
        if (!originalName || !newName || originalName === newName) return;
        
        // Update stored playerCreationOrder for the current game
        if (currentGameId && games[currentGameId] && Array.isArray(games[currentGameId].playerCreationOrder)) {
          const pco = games[currentGameId].playerCreationOrder;
          for (let i = 0; i < pco.length; i++) {
            if (pco[i] === originalName) pco[i] = newName;
          }
        }
        
        // Update any stored rounds that reference the player name
        if (Array.isArray(rounds)) {
          for (const round of rounds) {
            if (round && Array.isArray(round.players)) {
              for (const [i, p] of round.players.entries()) {
                if (p === originalName) round.players[i] = newName;
              }
            }
          }
        }
        
        // Transfer elimination level tracking for the player
        if (eliminationLevels && Object.hasOwn(eliminationLevels, originalName)) {
          const val = eliminationLevels[originalName];
          delete eliminationLevels[originalName];
          eliminationLevels[newName] = val;
        }
        
        // Update lastReplacements entries
        if (Array.isArray(lastReplacements)) {
          lastReplacements.forEach(rep => {
            if (!rep) return;
            if (rep.eliminated === originalName) rep.eliminated = newName;
            if (rep.replacement === originalName) rep.replacement = newName;
          });
        }
        
        // If the player who triggered the 25-point rule is being renamed, update that reference
        if (elimination25UsedBy === originalName) {
          elimination25UsedBy = newName;
          if (typeof setElimination25UsedBy === 'function') setElimination25UsedBy(newName);
          if (currentGameId && games[currentGameId]) {
            games[currentGameId].elimination25UsedBy = newName;
          }
        }
        
        // Ensure persisted game record reflects updated rounds on server/local snapshot
        if (currentGameId && games[currentGameId]) {
          games[currentGameId].rounds = rounds;
          // Try to persist full game (including rounds) to server; falls back to local persist
          saveGame(currentGameId, true).catch(err => {
            console.warn('saveGame(includeRounds) failed', err);
            persistLocalGames();
          });
        }
      }

      // Generic edit modal handlers
      function openGenericEditModal(kind, data) {
        try {
          globalThis._genericEdit = { kind: kind, data: data };
          const titleEl = document.getElementById('genericEditTitle');
          const labelEl = document.getElementById('genericEditLabel');
          const input = document.getElementById('genericEditInput');
          if (kind === 'player') {
            titleEl.textContent = 'Edit Player Name';
            labelEl.textContent = 'Player name:';
            input.value = data.originalName || '';
          } else if (kind === 'game') {
            titleEl.textContent = 'Edit Game Name';
            labelEl.textContent = 'Game name:';
            input.value = data.originalName || '';
          } else {
            titleEl.textContent = 'Edit';
            labelEl.textContent = 'Value:';
            input.value = data && data.originalName ? data.originalName : '';
          }
          setTimeout(() => { input.focus(); input.select(); }, 50);
          const modal = document.getElementById('genericEditModal'); if (modal) modal.style.display = 'block';
          // push history state so back button closes the modal
          try {
            if (!history.state || history.state.modal !== 'genericEdit') {
              history.pushState({ modal: 'genericEdit', sub: kind }, '');
              globalThis._genericEditStatePushed = true;
            }
          } catch (e) { console.warn('openGenericEditModal: history.pushState failed', e); }
        } catch (e) { console.warn('openGenericEditModal failed', e); }
      }
      
      function confirmGenericEditModal() {
        try {
          const state = globalThis._genericEdit || null;
          if (!state) return cancelGenericEditModal();
          const input = document.getElementById('genericEditInput');
          if (!input) return cancelGenericEditModal();
          const newVal = String(input.value || '').trim();
          if (!newVal) {
            if (state.kind === 'game') { alert('Please enter a game name'); } else { alert('Player name cannot be empty'); }
            input.focus();
            return;
          }
          
          if (state.kind === 'player') {
            const { playerType, index, originalName } = state.data;
            if (newVal === originalName) { cancelGenericEditModal(); return; }
            const allNames = [];
            players.active.forEach((p, i) => { if (p !== null && !(playerType === 'active' && i === index)) allNames.push(p); });
            players.queue.forEach((p, i) => { if (!(playerType === 'queue' && i === index)) allNames.push(p); });
            if (allNames.includes(newVal)) { alert('A player with this name already exists'); return; }
            if (playerType === 'active') players.active[index] = newVal; else players.queue[index] = newVal;
            
            renamePlayerAcrossGame(originalName, newVal);
            saveCurrentGame();
            
            renderPlayers();
            updateGameDisplay();
          } else if (state.kind === 'game') {
            const { gameId, originalName } = state.data;
            if (!games[gameId]) { alert('Game not found'); cancelGenericEditModal(); return; }
            if (newVal === originalName) { cancelGenericEditModal(); return; }
            for (const [id, g] of Object.entries(games)) {
              if (id !== gameId && g && g.name === newVal) { alert('A game with this name already exists'); return; }
            }
            games[gameId].name = newVal;
            persistLocalGames();
            // Persist the game's metadata and handle failures explicitly.
            saveGame(gameId, false).catch(err => console.warn('saveGame failed', err));
            renderGamesManagement();
            if (currentGameId === gameId) { const el = document.getElementById('gameTitle'); if (el) el.textContent = newVal; }
          }
          
          // Close modal and cleanup history state
          const modal = document.getElementById('genericEditModal'); if (modal) modal.style.display = 'none';
          if (history.state && history.state.modal === 'genericEdit') history.back();
          globalThis._genericEdit = null;
        } catch (e) { console.warn('confirmGenericEditModal failed', e); }
      }
      
      function cancelGenericEditModal() {
        try {
          const modal = document.getElementById('genericEditModal'); if (modal) modal.style.display = 'none';
          try { if (history.state && history.state.modal === 'genericEdit') history.back(); } catch (e) { console.warn('cancelGenericEditModal: history.back failed', e); }
          globalThis._genericEdit = null;
          renderPlayers();
        } catch (e) { console.warn('cancelGenericEditModal failed', e); }
      }
      
      function activatePlayerToSeat(playerName, seatIndex) {
        const queueIndex = players.queue.indexOf(playerName);
        if (queueIndex > -1 && players.active[seatIndex] === null) {
          players.queue.splice(queueIndex, 1);
          players.active[seatIndex] = playerName;
          saveCurrentGame();
          renderPlayers();
          updateGameDisplay();
        }
      }
      
      function activatePlayer(playerName) {
        // Find first empty seat
        const queueIndex = players.queue.indexOf(playerName);
        if (queueIndex > -1) {
          const emptySeatIndex = players.active.indexOf(null);
          if (emptySeatIndex > -1) {
            activatePlayerToSeat(playerName, emptySeatIndex);
          } else if (players.active.length < 4) {
            // Add to end if no empty seats but still room
            players.queue.splice(queueIndex, 1);
            players.active.push(playerName);
            saveCurrentGame();
            renderPlayers();
            updateGameDisplay();
          }
        }
      }
      
      // Drag and Drop Functions
      let draggedElement = null;
      let draggedIndex = null;
      let draggedType = null;
      
      function handleDragStart(e) {
        const element = e.currentTarget;
        draggedElement = element;
        draggedIndex = Number.parseInt(element.dataset.index);
        draggedType = element.dataset.type;
        
        element.classList.add('dragging');
        e.dataTransfer.effectAllowed = 'move';
        e.dataTransfer.setData('text/html', element.innerHTML);
        
        // Add a slight delay to show dragging effect
        setTimeout(() => {
          if (draggedElement) {
            draggedElement.style.opacity = '0.6';
          }
        }, 0);
      }
      
      function handleDragEnd(e) {
        const element = e.currentTarget;
        element.classList.remove('dragging');
        element.style.opacity = '';
        
        // Finalize the changes by updating the data and re-rendering
        saveCurrentGame();
        renderPlayers();
        updateGameDisplay();
        
        draggedElement = null;
        draggedIndex = null;
        draggedType = null;
      }
      
      function handleDragOver(e) {
        if (e.preventDefault) {
          e.preventDefault();
        }
        
        const targetElement = e.currentTarget;
        const targetType = targetElement.dataset.type;
        
        // Only allow dropping on items of the same type
        if (draggedType !== targetType || !draggedElement || targetElement === draggedElement) {
          return;
        }
        
        e.dataTransfer.dropEffect = 'move';
        
        // Perform live reordering preview
        const container = targetElement.parentNode;
        const allItems = Array.from(container.children).filter(el => el.classList.contains('player-item'));
        
        // Get current positions
        const draggedPos = allItems.indexOf(draggedElement);
        const targetPos = allItems.indexOf(targetElement);
        
        if (draggedPos === -1 || targetPos === -1) {
          return;
        }
        
        // Reorder DOM elements for visual preview
        if (draggedPos < targetPos) {
          // Moving down - insert after target
          targetElement.parentNode.insertBefore(draggedElement, targetElement.nextSibling);
        } else if (draggedPos > targetPos) {
          // Moving up - insert before target
          targetElement.parentNode.insertBefore(draggedElement, targetElement);
        } else {
          // Same position, no need to move
          return;
        }
        
        // Get the new position after DOM reordering
        const newAllItems = Array.from(container.children).filter(el => el.classList.contains('player-item'));
        const newDraggedPos = newAllItems.indexOf(draggedElement);
        
        // Update the data array to match visual order
        if (draggedType === 'active') {
          const item = players.active[draggedIndex];
          players.active.splice(draggedIndex, 1);
          players.active.splice(newDraggedPos, 0, item);
        } else if (draggedType === 'queue') {
          const item = players.queue[draggedIndex];
          players.queue.splice(draggedIndex, 1);
          players.queue.splice(newDraggedPos, 0, item);
        }
        
        // Update draggedIndex to the new position
        draggedIndex = newDraggedPos;
        
        // Update data-index attributes for all items to match their current DOM position
        newAllItems.forEach((item, idx) => {
          item.dataset.index = idx;
        });
      }
      
      function handleDragLeave(e) {
        // Don't need to do anything here with live preview
      }
      
      function handleDrop(e) {
        if (e.stopPropagation) {
          e.stopPropagation();
        }
        e.preventDefault();
        
        // Data is already updated during dragover, just finalize
      }
      
      // Create a player-item element for active or queue lists
      function createPlayerItem(playerName, type, index, statsMap) {
        const item = document.createElement('div');
        item.dataset.index = index;
        item.dataset.type = type;
        
        if (type === 'active') {
          if (playerName === null) {
            item.className = 'player-item empty-seat';
            item.innerHTML = `
              <div>
                <div class="player-name">Empty Seat</div>
                <div class="player-position">Seat #${index + 1}</div>
              </div>
              <div class="player-actions">
                ${players.queue.length > 0 ? 
                `<select class="seat-selector" onchange="activatePlayerToSeat(this.value, ${index}); this.value=''">
                    <option value="">Select Player...</option>
                    ${players.queue.map(queuedPlayer => 
                  `<option value="${queuedPlayer}">${queuedPlayer}</option>`
                  ).join('')}
                  </select>` : 
                  '<span class="no-queue">No players in queue</span>'
                  }
              </div>
            `;
          } else {
            const stats = statsMap ? statsMap[playerName] : null;
            const hasPlayedRounds = stats && stats.roundsPlayed > 0;
            const totalScore = hasPlayedRounds ? stats.totalScore : '-';
            
            item.className = 'player-item active';
            item.draggable = true;
            item.innerHTML = `
              <span class="drag-handle">‚ãÆ‚ãÆ</span>
              <div style="flex: 1;">
                <div class="player-name" id="activeName_${index}">${playerName}</div>
                <div class="player-position">Seat #${index + 1} ¬∑ Score: ${totalScore}</div>
              </div>
              <div class="player-actions">
                <button class="btn-small bg-white" onclick="editPlayerName('${playerName}', 'active', ${index})">Edit</button>
                <button class="btn-small bg-yellow" onclick="demotePlayer('${playerName}')">Move to Queue</button>
              </div>
            `;
          }
        } else if (type === 'queue') {
          const stats = statsMap ? statsMap[playerName] : null;
          const hasPlayedRounds = stats && stats.roundsPlayed > 0;
          const totalScore = hasPlayedRounds ? stats.totalScore : '-';
          
          item.className = 'player-item';
          item.draggable = true;
          item.innerHTML = `
            <span class="drag-handle">‚ãÆ‚ãÆ</span>
            <div style="flex: 1;">
              <div class="player-name" id="queueName_${index}">${playerName}</div>
              <div class="player-position">Queue position ${index + 1} ¬∑ Score: ${totalScore}</div>
            </div>
            <div class="player-actions">
              <button class="btn-small bg-white" onclick="editPlayerName('${playerName}', 'queue', ${index})">Edit</button>
              ${players.active.includes(null) ? `<button class="btn-small bg-blue" onclick="activatePlayer('${playerName}')">Take Next Seat</button>` : ''}
            </div>
          `;
        }
        
        return item;
      }
      
      function attachDragListeners(el) {
        el.addEventListener('dragstart', handleDragStart);
        el.addEventListener('dragend', handleDragEnd);
        el.addEventListener('dragover', handleDragOver);
        el.addEventListener('drop', handleDrop);
        el.addEventListener('dragleave', handleDragLeave);
      }
      
      function renderPlayers() {
        // Calculate player stats first
        const playerStats = calculatePlayerTileStats();
        
        // Create a map for quick lookup
        const statsMap = {};
        playerStats.forEach(stat => {
          statsMap[stat.name] = stat;
        });
        
        // Render active players (including empty seats)
        const activeList = document.getElementById("activePlayersList");
        activeList.innerHTML = "";
        
        // Ensure we always show 4 seats
        while (players.active.length < 4) {
          players.active.push(null);
        }
        
        players.active.forEach((playerName, index) => {
          const playerItem = createPlayerItem(playerName, 'active', index, statsMap);
          if (playerName !== null) attachDragListeners(playerItem);
          activeList.appendChild(playerItem);
        });
        
        // Render queued players
        const queueList = document.getElementById("queuePlayersList");
        queueList.innerHTML = "";
        
        if (players.queue.length === 0) {
          queueList.innerHTML = '<div class="empty-list">No players in queue</div>';
        } else {
          players.queue.forEach((playerName, index) => {
            const playerItem = createPlayerItem(playerName, 'queue', index, statsMap);
            attachDragListeners(playerItem);
            queueList.appendChild(playerItem);
          });
        }
      }
      
      function updateGameDisplay() {
        // Update game title
        const currentGame = games[currentGameId];
        const gameTitle = document.getElementById('gameTitle');
        if (gameTitle && currentGame) gameTitle.textContent = currentGame.name;
        
        // Calculate player statistics and helpers
        const playerStats = calculatePlayerTileStats();
        const leader = getLeader(playerStats);
        const leaderSet = new Set((leader || []).map(l => l.name));
        const statsMap = {};
        playerStats.forEach(s => { statsMap[s.name] = s; });
        
        // Last round winner
        const lastRoundWinner = getLastRoundWinner(rounds);
        
        // Render player tiles
        let activePlayerCount = 0;
        for (let i = 0; i < 4; i++) {
          const playerName = players.active[i];
          const active = renderPlayerTile(i, playerName, statsMap, leaderSet, lastRoundWinner);
          if (active) activePlayerCount++;
          
          // Update modal labels per seat
          const label = document.querySelector(`label[for="p${i + 1}Score"]`);
          if (label) {
            const defaultPlayerName = 'Player ' + (i + 1);
            label.textContent = (playerName || defaultPlayerName) + ' Cards:';
          }
        }
        
        // Update queue display
        renderQueueDisplay(statsMap, leaderSet);
        
        // Update Add Round button
        updateAddRoundButton(activePlayerCount);
        
        // Re-render current view if needed
        const currentView = getCurrentView();
        if (currentView === 'statistics') renderStatistics();
        else if (currentView === 'history') updateHistoryDisplay();
        
        // Update legacy score display for compatibility
        render();
      }
      
      // Common function to parse round data into consistent format
      function parseRoundData(roundData) {
        if (roundData && roundData.points) {
          // Standard format: includes player names, points, and cards
          return {
            points: roundData.points,
            playerNames: roundData.players || [null, null, null, null],
            cards: roundData.cards || [0, 0, 0, 0]
          };
        } else {
          // Fallback for missing data
          return {
            points: [0, 0, 0, 0],
            playerNames: [null, null, null, null],
            cards: [0, 0, 0, 0]
          };
        }
        
      }
      
      // Helper: get last round winner (name or null)
      function getLastRoundWinner(roundsList) {
        if (!roundsList || roundsList.length === 0) return null;
        const lastRound = roundsList[roundsList.length - 1];
        const cards = lastRound.cards || [];
        const playerNames = lastRound.players || [];
        for (let i = 0; i < cards.length; i++) {
          if (cards[i] === 0 && playerNames[i]) return playerNames[i];
        }
        return null;
      }
      
      // Helper: safely insert element after a reference (with fallbacks)
      function safeInsertAfter(refElem, newElem) {
        if (!refElem || !newElem) return false;
        if (typeof refElem.after === 'function') {
          refElem.after(newElem);
          return true;
        }
        if (refElem.parentNode) {
          refElem.parentNode.insertBefore(newElem, refElem.nextSibling);
          return true;
        }
        return false;
      }

      // Helper: initialize runtime metadata for local-only games
      // `prefix` is used for contextual logging (e.g. 'Immediate local load')
      function initLocalOnlyGamesMetadata(localOnlyGames, prefix) {
        Object.keys(localOnlyGames).forEach(id => {
          try {
            games_metadata[id] = games_metadata[id] || {};
            games_metadata[id].roundsLoaded = true;
            let _rc = 0;
            if (Array.isArray(localOnlyGames[id].rounds)) {
              _rc = localOnlyGames[id].rounds.length;
            } else if (typeof localOnlyGames[id].roundCount === 'number') {
              _rc = localOnlyGames[id].roundCount;
            }
            games_metadata[id].roundCount = _rc;
            games_metadata[id].localOnly = true;
          } catch (e) { console.warn(prefix + ': per-game metadata init failed for', id, e); }
        });
      }
      
      // Helper: compute elimination indicator info
      function computeEliminationInfo(playerName, stats) {
        const levelsReached = eliminationLevels[playerName] || 0;
        const currentTotal = (stats && stats.roundsPlayed > 0) ? stats.totalScore : 0;
        const candidates = [];
        if (!elimination25UsedBy && currentTotal < 25) candidates.push({ threshold: 25, type: '25' });
        const next50 = (levelsReached + 1) * 50;
        if (next50 > currentTotal) candidates.push({ threshold: next50, type: '50' });
        
        if (candidates.length === 0) return { distance: Infinity, chosen: null };
        
        const chosen = candidates.reduce((best, c) => {
          const d = c.threshold - currentTotal;
          if (d <= 0) return best;
          if (!best) return c;
          return d < (best.threshold - currentTotal) ? c : best;
        }, null);
        
        const distance = chosen ? (chosen.threshold - currentTotal) : Infinity;
        return { distance, chosen, currentTotal, levelsReached };
      }
      
      // Helper: render a single player tile; returns true if player is active (not null)
      function renderPlayerTile(index, playerName, statsMap, leaderSet, lastRoundWinner) {
        const tile = document.getElementById(`playerTile${index + 1}`);
        const totalElement = document.getElementById(`tileTotal${index + 1}`);
        const avgElement = document.getElementById(`tileAvg${index + 1}`);
        const roundsElement = document.getElementById(`tileRounds${index + 1}`);
        
        if (!tile || !totalElement || !avgElement || !roundsElement) return false;
        
        const nameElement = tile.querySelector('.player-name');
        const crownElement = tile.querySelector('.leader-crown');
        const lastRoundWinnerElement = tile.querySelector('.last-round-winner');
        
        if (playerName === null) {
          if (nameElement) nameElement.textContent = `[Empty Seat ${index + 1}]`;
          tile.className = 'player-tile empty-seat';
          totalElement.textContent = '-';
          avgElement.textContent = '-';
          roundsElement.textContent = '-';
          if (crownElement) crownElement.style.display = 'none';
          if (lastRoundWinnerElement) lastRoundWinnerElement.style.display = 'none';
          return false;
        }
        
        // Active player
        if (nameElement) nameElement.textContent = playerName;
        const isLeader = leaderSet && leaderSet.has(playerName);
        tile.className = isLeader ? 'player-tile leader' : 'player-tile';
        
        const stats = statsMap[playerName];
        if (stats && stats.roundsPlayed > 0) {
          totalElement.textContent = stats.totalScore;
          avgElement.textContent = stats.avgScore.toFixed(1);
          roundsElement.textContent = stats.roundsPlayed;
        } else {
          totalElement.textContent = '-';
          avgElement.textContent = '-';
          roundsElement.textContent = '0';
        }
        
        if (crownElement) crownElement.style.display = isLeader ? 'inline' : 'none';
        
        if (lastRoundWinnerElement) {
          lastRoundWinnerElement.style.display = (lastRoundWinner === playerName) ? 'inline' : 'none';
        }
        
        // Elimination indicator
        const elimInfo = computeEliminationInfo(playerName, stats);
        let elimElem = tile.querySelector('.elim-remaining');
        if (!elimElem) {
          elimElem = document.createElement('div');
          elimElem.className = 'elim-remaining';
          
          const roundsStat = (typeof roundsElement.closest === 'function') ? roundsElement.closest('.stat-item') : null;
          if (roundsStat) {
            if (typeof roundsStat.after === 'function') {
              roundsStat.after(elimElem);
            } else if (roundsStat.parentNode) {
              roundsStat.parentNode.insertBefore(elimElem, roundsStat.nextSibling);
            } else {
              tile.appendChild(elimElem);
            }
          } else {
            tile.appendChild(elimElem);
          }
        }
        
        if (elimInfo.distance > 0 && elimInfo.distance <= 7) {
          const plural = elimInfo.distance === 1 ? 'point' : 'points';
          elimElem.innerHTML = `<span class="elim-symbol">‚ö†Ô∏è</span>${elimInfo.distance} ${plural} from elimination`;
          elimElem.style.display = 'block';
        } else if (elimElem) {
          elimElem.style.display = 'none';
        }
        
        return true;
      }
      
      // Helper: update add round button
      function updateAddRoundButton(activePlayerCount) {
        const addRoundBtn = document.getElementById('addRoundBtn');
        if (!addRoundBtn) return;
        const nextRoundNumber = rounds.length + 1;
        if (activePlayerCount === 0) {
          addRoundBtn.disabled = true;
          addRoundBtn.textContent = '‚ñ∂Ô∏è Round 1 (Need Players)';
        } else {
          addRoundBtn.disabled = false;
          addRoundBtn.textContent = `‚ñ∂Ô∏è Round ${nextRoundNumber}`;
        }
      }
      
      // Helper: render queue display
      function renderQueueDisplay(statsMap, leaderSet) {
        const queuePlayerCards = document.getElementById('queuePlayerCards');
        if (!queuePlayerCards) return;
        if (players.queue.length === 0) {
          queuePlayerCards.innerHTML = '<div class="queue-no-players">No players in queue</div>';
          return;
        }
        
        const queueHTML = players.queue.map((playerName, idx) => {
          const stats = statsMap[playerName];
          const isLeader = leaderSet && leaderSet.has(playerName);
          if (stats && stats.roundsPlayed > 0) {
            return `
              <div class="queue-player-card${isLeader ? ' leader-queue' : ''}">
                <div class="queue-player-header">
                  <div class="queue-order">${idx + 1}</div>
                  <div class="queue-player-name">
                    ${playerName}
                    ${isLeader ? ' <span class="leader-crown">üëë</span>' : ''}
                  </div>
                </div>
                <div class="queue-player-stats">
                  <span>Total: ${stats.totalScore}</span>
                  <span>Avg: ${stats.avgScore.toFixed(1)}</span>
                </div>
              </div>
            `;
          }
          return `
            <div class="queue-player-card">
              <div class="queue-player-header">
                <div class="queue-order">${idx + 1}</div>
                <div class="queue-player-name">${playerName}</div>
              </div>
              <div class="queue-player-stats">
                <span>Total: -</span>
                <span>Avg: -</span>
              </div>
            </div>
          `;
        }).join('');
        
        queuePlayerCards.innerHTML = queueHTML;
      }
      
      // Common function to switch between views
      function switchView(viewId) {
        const views = ['gameView', 'historyView', 'statisticsView', 'playersView', 'newGameView', 'gamesManagementView', 'noGamesView'];
        views.forEach(id => {
          const el = document.getElementById(id);
          if (!el) return;
          el.style.display = id === viewId ? 'block' : 'none';
        });
      }
      
      // Common function to calculate player totals across all rounds
      function calculatePlayerTotals() {
        return computeTotals(rounds, players);
      }
      
      function calculatePlayerTileStats() {
        const { playerTotals, playerRounds, playerAverages } = calculatePlayerTotals();
        
        // Convert to array format for compatibility
        const playerStats = [];
        Object.keys(playerTotals).forEach(name => {
          playerStats.push({
            name: name,
            totalScore: playerTotals[name],
            avgScore: playerAverages[name],
            roundsPlayed: playerRounds[name]
          });
        });
        
        return playerStats;
      }
      
      function getLeader(playerStats) {
        if (playerStats.length === 0) return [];
        
        // Filter players who have played at least one round
        const activePlayers = playerStats.filter(p => p.roundsPlayed > 0);
        if (activePlayers.length === 0) return [];
        
        // Find lowest average score
        let minAvgScore = activePlayers[0].avgScore;
        for (let i = 1; i < activePlayers.length; i++) {
          if (activePlayers[i].avgScore < minAvgScore) {
            minAvgScore = activePlayers[i].avgScore;
          }
        }
        
        // Get all players with the lowest average score
        const playersWithMinAvg = activePlayers.filter(p => p.avgScore === minAvgScore);
        
        // Among those, find the maximum rounds played
        let maxRounds = playersWithMinAvg[0].roundsPlayed;
        for (let i = 1; i < playersWithMinAvg.length; i++) {
          if (playersWithMinAvg[i].roundsPlayed > maxRounds) {
            maxRounds = playersWithMinAvg[i].roundsPlayed;
          }
        }
        
        // Return all players with lowest avg score AND most rounds played
        return playersWithMinAvg.filter(p => p.roundsPlayed === maxRounds);
      }
      
      function getCurrentView() {
        if (document.getElementById('gameView').style.display !== 'none') return 'game';
        if (document.getElementById('historyView').style.display === 'block') return 'history';
        if (document.getElementById('statisticsView').style.display === 'block') return 'statistics';
        if (document.getElementById('playersView').style.display === 'block') return 'players';
        return 'game';
      }
      
        // Helper: apply preloaded local-only games parsed from storage.
        // If `preserveCurrent` is true, keep existing `currentGameId` when possible;
        // otherwise choose the last-open or first available local-only game.
        function applyPreloadedLocalGames(parsed, preserveCurrent) {
          try {
            if (!parsed || typeof parsed !== 'object' || Object.keys(parsed).length === 0) return false;
            const localOnlyGames = {};
            Object.keys(parsed).forEach(id => {
              try {
                if (parsed[id] && parsed[id].localOnly === true) localOnlyGames[id] = parsed[id];
              } catch (e) { console.warn('applyPreloadedLocalGames: skipping malformed game entry', id, parsed?.[id], e); }
            });
            games = localOnlyGames;
            // Initialize runtime metadata for these preloaded local-only games
            try {
              initLocalOnlyGamesMetadata(localOnlyGames, 'applyPreloadedLocalGames');
            } catch (e) {console.warn('applyPreloadedLocalGames: failed to init games_metadata for preloaded local games', e); }

            const last = localStorage.getItem('cardgame-current-game');
            if (preserveCurrent) {
              currentGameId = (last && games[last]) ? last : currentGameId;
            } else {
              currentGameId = (last && games[last]) ? last : Object.keys(games)[0] || null;
            }
            return true;
          } catch (e) { console.warn('applyPreloadedLocalGames failed', e); return false; }
        }
      
      function initializeGames() {
        // Load games from server (or create default if none). This function performs an initial sync with the backend.
        if (!serverAvailable) {
          // Offline: restore saved games from GAMES_STORAGE_KEY using safe loader.
          const parsed = safeLoadStoredGames();
          const applied = applyPreloadedLocalGames(parsed, false);
          if (!applied) {
            games = {};
            currentGameId = null;
          }
          loadCurrentGame();
          renderGameList();
          return Promise.resolve();
        }
        
        // Load any locally persisted games first so the UI can show them immediately
        try {
          const parsed = safeLoadStoredGames();
          const applied = applyPreloadedLocalGames(parsed, true);
          if (!applied) {
            games = {};
            currentGameId = null;
          }
          // Render early so users see local games while the fetch runs
          loadCurrentGame();
          renderGameList();
        } catch (e) { console.warn('initializeGames: failed to preload stored local games', e); }

        return fetch(API_BASE + '/api/games')
        .then(r => {
          if (r && r.ok) return r.json();
          throw new Error('Failed to fetch');
        })
        .then(list => {
          if (Array.isArray(list) && list.length > 0) {
            // Convert array to keyed object like previous local model, but list may be metadata-only
            // If we already have locally-created games (e.g. the user created a game while
            // the initial fetch was in-flight), merge server entries instead of replacing
            // the entire `games` object so we don't clobber newly-created local games.
            const replaceAll = !games || Object.keys(games).length === 0;
            if (replaceAll) games = {};
            list.forEach(g => {
              // If `data` is present, server returned full object; otherwise treat as metadata
              if (g.data) {
                const entry = g.data || {};
                entry.rounds = entry.rounds || [];
                entry.players = entry.players || { active: ["Player 1","Player 2","Player 3","Player 4"], queue: [] };
                entry.eliminationLevels = entry.eliminationLevels || {};
                entry.elimination25UsedBy = entry.elimination25UsedBy || null;
                entry.playerCreationOrder = g.playerCreationOrder || (entry.players ? [...entry.players.active.filter(Boolean), ...entry.players.queue] : []);
                entry.createdAt = g.createdAt || Date.now();
                // Merge into existing games map, preferring existing local entry when present
                games[g.id] = games[g.id] && Object.keys(games[g.id]).length > 0 ? { ...entry, ...games[g.id] } : entry;
                games_metadata[g.id] = games_metadata[g.id] || {};
                games_metadata[g.id].roundsLoaded = true;
                games_metadata[g.id].roundCount = (games[g.id].rounds || []).length;
                games_metadata[g.id].localOnly = false;
              } else {
                // Metadata-only entry: keep canonical fields on `games` but store counts/loaded flag in `games_metadata`
                if (!games[g.id] || Object.keys(games[g.id]).length === 0) {
                  games[g.id] = {
                    name: g.name || 'Game',
                    createdAt: g.createdAt || Date.now(),
                    playerCreationOrder: g.playerCreationOrder || [],
                    rounds: [],
                  };
                } else {
                  // Preserve any richer local copy
                  games[g.id].name = games[g.id].name || g.name || 'Game';
                }
                games_metadata[g.id] = games_metadata[g.id] || {};
                games_metadata[g.id].roundCount = g.roundCount || 0;
                games_metadata[g.id].roundsLoaded = false;
                games_metadata[g.id].localOnly = false;
              }
              games[g.id].name = games[g.id].name || g.name || 'Game';
            });
          } else if (!games || Object.keys(games).length === 0) {
            games = {};
          }

          // Local-only games were preloaded before the server fetch; no further merge needed here.
        })
        .then(() => {
          // Ensure we have a currentGameId
          if (!currentGameId || !games[currentGameId]) {
            currentGameId = Object.keys(games)[0];
            if (currentGameId) localStorage.setItem('cardgame-current-game', currentGameId);
          }
        })
        .then(() => {
          // Load current game; if the server provided metadata only, fetch full game data on demand
          loadCurrentGame();
          renderGameList();
        })
        .catch(err => {
          console.warn('Failed to initialize games from server, starting with empty state', err);
          // Start empty if nothing available
          if (!games || Object.keys(games).length === 0) {
            games = {};
            currentGameId = null;
          }
          loadCurrentGame();
          renderGameList();
        });
      }
      
      function saveGames() {
        // Persist games to backend; fall back to localStorage on error
        try {
          // Only persist non-localOnly games remotely. Exclude `rounds` (they're appended via POST).
          const idsForRemote = Object.keys(games).filter(id => !(games[id] && games[id].localOnly));
          const entries = idsForRemote.map(id => {
            const game = games[id] || {};
            const dataCopy = { ...game };
            if (dataCopy.hasOwnProperty('rounds')) delete dataCopy.rounds;
            const payload = { id: id, name: dataCopy.name || (`Game ${id}`), data: dataCopy };
            return fetch(API_BASE + '/api/games/' + encodeURIComponent(id), {
              method: 'PUT',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify(payload)
            });
          });
          Promise.all(entries).then(() => {
            // Always persist a local copy as backup (includes localOnly games)
            persistLocalGames();
          }).catch(err => {
            console.warn('saveGames: remote save failed, falling back to localStorage', err);
            persistLocalGames();
          });
        } catch (e) {
          console.warn('saveGames: unexpected error while saving remotely, falling back to local persist', e);
          persistLocalGames();
        }
      }
      
      // Save a single game to the server (or persist locally). By default this sends
      // metadata only (no `rounds`) to avoid large payloads. Set includeRounds=true
      // to send the full game object including `rounds` (used when incremental append fails).
      function saveGame(gameId, includeRounds = false) {
        if (!gameId || !games[gameId]) return Promise.resolve();
        const game = games[gameId];
        // If local-only or server not available, persist locally
        if (!serverAvailable || game.localOnly) {
          persistLocalGames();
          return Promise.resolve();
        }
        
        const dataCopy = { ...game };
        if (!includeRounds && dataCopy.hasOwnProperty('rounds')) delete dataCopy.rounds;
        
        const payload = { id: gameId, name: dataCopy.name || (`Game ${gameId}`), data: dataCopy };
        return fetch(API_BASE + '/api/games/' + encodeURIComponent(gameId), {
          method: 'PUT',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(payload)
        }).then(resp => {
          if (!resp.ok) throw new Error('saveGame: remote save failed: ' + resp.status);
          persistLocalGames();
          return resp.json();
        }).catch(err => {
          console.warn('saveGame: remote save failed, falling back to local persist', err);
          persistLocalGames();
          throw err;
        });
      }
      
      function formatTimestamp(ts) {
        if (!ts) return '';
        const num = Number(ts);
        if (Number.isNaN(num)) return '';
        const d = new Date(num);
        if (!d || Number.isNaN(d.getTime())) return '';
        const dd = String(d.getDate()).padStart(2, '0');
        const mm = String(d.getMonth() + 1).padStart(2, '0');
        const yyyy = d.getFullYear();
        const hh = String(d.getHours()).padStart(2, '0');
        const min = String(d.getMinutes()).padStart(2, '0');
        return `${dd}.${mm}.${yyyy} ${hh}:${min}`;
      }
      globalThis.formatTimestamp = formatTimestamp;
      
      function loadCurrentGame() {
        if (Object.keys(games).length === 0) {
          currentGameId = null;
          showNoGames();
          return;
        }
        
        if (currentGameId && games[currentGameId]) {
          const game = games[currentGameId];
          // If we don't have rounds loaded for this game and server is available, fetch full game
          const roundsLoadedFlag = (games_metadata && games_metadata[currentGameId] && games_metadata[currentGameId].roundsLoaded) || false;
          if (serverAvailable && !roundsLoadedFlag && !game.localOnly) {
            fetch(API_BASE + '/api/games/' + encodeURIComponent(currentGameId))
            .then(r => {
              if (r && r.ok) return r.json();
              throw new Error('Failed to fetch game');
            })
            .then(payload => {
              const data = payload.data || payload;
              games[currentGameId] = games[currentGameId] || {};
              // Merge server data
              games[currentGameId].rounds = data.rounds || [];
              games[currentGameId].players = data.players || games[currentGameId].players || { active: ["Player 1","Player 2","Player 3","Player 4"], queue: [] };
              games[currentGameId].eliminationLevels = data.eliminationLevels || games[currentGameId].eliminationLevels || {};
              games[currentGameId].elimination25UsedBy = data.elimination25UsedBy || null;
              games[currentGameId].playerCreationOrder = data.playerCreationOrder || games[currentGameId].playerCreationOrder || [];
              games[currentGameId].createdAt = payload.createdAt || games[currentGameId].createdAt || Date.now();
              games_metadata[currentGameId] = games_metadata[currentGameId] || {};
              games_metadata[currentGameId].roundsLoaded = true;
              games_metadata[currentGameId].roundCount = (games[currentGameId].rounds || []).length;
              // Now assign to runtime variables and render
              rounds = games[currentGameId].rounds || [];
              players = { active: [...games[currentGameId].players.active], queue: [...games[currentGameId].players.queue] };
              eliminationLevels = games[currentGameId].eliminationLevels ? {...games[currentGameId].eliminationLevels} : {};
              elimination25UsedBy = games[currentGameId].elimination25UsedBy || null;
              updateGameDisplay();
              render();
            }).catch(err => {
              console.warn('loadCurrentGame: failed to fetch full game, using local/memoized data', err);
              rounds = game.rounds || [];
            });
            return;
          }
          
          rounds = game.rounds || [];
          
          // Load game-specific players or use defaults
          if (game.players) {
            // Create deep copy to avoid sharing references between games
            players = {
              active: [...game.players.active],
              queue: [...game.players.queue]
            };
            eliminationLevels = game.eliminationLevels ? {...game.eliminationLevels} : {};
            elimination25UsedBy = game.elimination25UsedBy || null;
          } else {
            // Migrate old games that don't have players stored
            players = {"active": ["Player 1", "Player 2", "Player 3", "Player 4"], "queue": []};
            // Create deep copy for the game object
            game.players = {
              active: [...players.active],
              queue: [...players.queue]
            };
            game.eliminationLevels = {};
            game.elimination25UsedBy = null;
            eliminationLevels = {};
            elimination25UsedBy = null;
            saveGames();
          }
          
          document.getElementById("gameTitle").textContent = game.name;
        } else {
          rounds = [];
          players = {"active": ["Player 1", "Player 2", "Player 3", "Player 4"], "queue": []};
          document.getElementById("gameTitle").textContent = "No Game Selected";
        }
      }
      
      // saveCurrentGame(alwaysPersist = true)
      // When called with false, this updates the local `games` object but
      // skips issuing the remote PUTs in `saveGames()`. This is useful when
      // an incremental API (POST /rounds) already persisted the new round.
      function saveCurrentGame(alwaysPersist = true) {
        if (currentGameId && games[currentGameId]) {
          games[currentGameId].rounds = rounds;
          // Create deep copy to avoid sharing references
          games[currentGameId].players = {
            active: [...players.active],
            queue: [...players.queue]
          };
          // preserve player creation order if present
          games[currentGameId].playerCreationOrder = games[currentGameId].playerCreationOrder || [...players.active.filter(Boolean), ...players.queue];
          // Persist elimination level tracking
          games[currentGameId].eliminationLevels = {...eliminationLevels};
          // Persist who triggered the 25-point elimination (if any)
          games[currentGameId].elimination25UsedBy = elimination25UsedBy || null;
          if (alwaysPersist) {
            // Persist only the current game's metadata to avoid sending all games
            saveGame(currentGameId, false).catch(err => {
              console.warn('saveCurrentGame: saveGame failed', err);
            });
          }
        }
      }
      
      function showNewGame() {
        switchView('newGameView');
        
        // Prefill game name with today's date (DD.MM.YYYY)
        const today = new Date();
        const dd = String(today.getDate()).padStart(2, '0');
        const mm = String(today.getMonth() + 1).padStart(2, '0');
        const yyyy = today.getFullYear();
        const defaultName = `${dd}.${mm}.${yyyy}`;
        const newGameNameEl = document.getElementById('newGameNameInput');
        if (newGameNameEl) newGameNameEl.value = defaultName;
        
        // Clear dynamic player inputs
        // Reset players container to default four input rows
        const container = document.getElementById('playersContainer');
        if (container) {
          container.innerHTML = `
            <div class="player-input-row">
              <input type="text" class="form-input player-name-input" placeholder="Player 1 Name">
              <button type="button" class="remove-player-btn" onclick="removePlayerInput(this)" style="display: none;">√ó</button>
            </div>
            <div class="player-input-row">
              <input type="text" class="form-input player-name-input" placeholder="Player 2 Name">
              <button type="button" class="remove-player-btn" onclick="removePlayerInput(this)" style="display: none;">√ó</button>
            </div>
            <div class="player-input-row">
              <input type="text" class="form-input player-name-input" placeholder="Player 3 Name">
              <button type="button" class="remove-player-btn" onclick="removePlayerInput(this)" style="display: none;">√ó</button>
            </div>
            <div class="player-input-row">
              <input type="text" class="form-input player-name-input" placeholder="Player 4 Name">
              <button type="button" class="remove-player-btn" onclick="removePlayerInput(this)" style="display: none;">√ó</button>
            </div>
          `;
          updateRemoveButtons();
          updatePlayerPlaceholders();
        }
        
        // Focus on game name input
        document.getElementById('newGameNameInput').focus();
      }
      
      function clearNewGameInputs() {
        const nameInput = document.getElementById('newGameNameInput');
        if (nameInput) {
          nameInput.value = '';
          nameInput.focus();
        }
        const inputs = document.querySelectorAll('.player-name-input');
        inputs.forEach(input => { input.value = ''; });
      }
      
      function showNoGames() {
        switchView('noGamesView');
        // Clear any transient state
        rounds = [];
        players = { active: [null, null, null, null], queue: [] };
        // Update title
        const titleEl = document.getElementById('gameTitle');
        if (titleEl) titleEl.textContent = 'No games';
      }
      
      function addPlayerInput() {
        const container = document.getElementById('playersContainer');
        const playerCount = container.children.length;
        
        const row = document.createElement('div');
        row.className = 'player-input-row';
        
        const input = document.createElement('input');
        input.type = 'text';
        input.className = 'form-input player-name-input';
        input.placeholder = `Player ${playerCount + 1} Name`;
        
        const removeBtn = document.createElement('button');
        removeBtn.type = 'button';
        removeBtn.className = 'remove-player-btn';
        removeBtn.textContent = '√ó';
        removeBtn.onclick = function() { removePlayerInput(this); };
        
        row.appendChild(input);
        row.appendChild(removeBtn);
        container.appendChild(row);
        
        updateRemoveButtons();
        
        // Focus on new input
        input.focus();
      }
      
      function removePlayerInput(button) {
        const row = button.parentElement;
        const container = document.getElementById('playersContainer');
        
        // Don't allow removing if only 4 players left
        if (container.children.length <= 4) {
          return;
        }
        
        row.remove();
        updateRemoveButtons();
        updatePlayerPlaceholders();
      }
      
      function updateRemoveButtons() {
        const container = document.getElementById('playersContainer');
        const removeButtons = container.querySelectorAll('.remove-player-btn');
        
        // Show remove buttons only if more than 4 players
        removeButtons.forEach(btn => {
          btn.style.display = container.children.length > 4 ? 'flex' : 'none';
        });
      }
      
      function updatePlayerPlaceholders() {
        const inputs = document.querySelectorAll('.player-name-input');
        inputs.forEach((input, index) => {
          input.placeholder = `Player ${index + 1} Name`;
        });
      }
      
      function createNewGameWithPlayers() {
        const gameName = document.getElementById('newGameNameInput').value.trim();
        const playerInputs = document.querySelectorAll('.player-name-input');
        const playerNames = Array.from(playerInputs).map(input => input.value.trim());
        
        // Validate game name
        if (!gameName) {
          alert('Please enter a game name');
          document.getElementById('newGameNameInput').focus();
          return;
        }

        // Check for duplicate game name (case-insensitive)
        try {
          const existingNames = Object.values(games).map(g => (g && g.name) ? String(g.name).toLowerCase() : '');
          if (existingNames.includes(gameName.toLowerCase())) {
            alert('A game with this name already exists');
            return;
          }
        } catch (e) { console.warn('createNewGameWithPlayers: error checking existing game names', e); }

        // Validate player names
        const filledNames = playerNames.filter(name => name !== '');
        if (filledNames.length < 4) {
          alert('Please enter at least 4 player names');
          return;
        }

        // Check for duplicate player names
        const uniqueNames = new Set(filledNames);
        if (uniqueNames.size !== filledNames.length) {
          alert('Player names must be unique');
          return;
        }
        
        // Ensure runtime 25-rule flag is reset for the new game
        elimination25UsedBy = null;
        try { if (typeof setElimination25UsedBy === 'function') setElimination25UsedBy(null); } catch (e) { console.warn('createNewGameWithPlayers: setElimination25UsedBy failed', e); }
        
        // Create new game
        const now = Date.now();
        const gameId = "game-" + now;
        
        // Set up players for this game
        const gamePlayers = {
          active: [],
          queue: []
        };
        
        // Put first 4 players (or all if less than 4) in active, rest in queue
        filledNames.forEach((name, index) => {
          if (index < 4) {
            gamePlayers.active.push(name);
          } else {
            gamePlayers.queue.push(name);
          }
        });
        
        // Fill active slots to 4 with nulls if needed
        while (gamePlayers.active.length < 4) {
          gamePlayers.active.push(null);
        }
        
        games[gameId] = {
          name: gameName,
          rounds: [],
          elimination25UsedBy: null,
          players: gamePlayers,
          eliminationLevels: {},
          playerCreationOrder: filledNames.slice(),
          createdAt: now,
        };
        const createToggle = document.getElementById('createLocalToggle');
        const userRequestedLocal = createToggle && createToggle.checked;
        const localOnly = userRequestedLocal || !serverAvailable;
        // Mark roundsLoaded in client-only metadata to avoid immediate refetch
        games_metadata[gameId] = games_metadata[gameId] || {};
        games_metadata[gameId].roundsLoaded = true;
        games_metadata[gameId].roundCount = 0;
        // Track client-only flags in runtime metadata (do not persist/send to server)
        games_metadata[gameId].localOnly = !!localOnly;
        // Also mark the stored game object as local-only so it persists that flag
        if (localOnly) games[gameId].localOnly = true;
        
        // Switch to new game and load its players with deep copy
        currentGameId = gameId;
        players = {
          active: [...gamePlayers.active],
          queue: [...gamePlayers.queue]
        };
        rounds = [];
        
        // Persist depending on online/state and toggle
        if (localOnly) {
          // Local-only creation
          saveCurrentGame(false); // skip remote PUTs
          persistLocalGames();
          localStorage.setItem("cardgame-current-game", currentGameId);
        } else {
          // Try to create on server first
          fetch(API_BASE + '/api/games', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ id: gameId, name: gameName, data: games[gameId] })
          }).then(r => {
            if (!r.ok) throw new Error('Server create failed');
            return r.json();
          }).then(res => {
            // Ensure local representation matches server
            games[gameId] = res.data || games[gameId];
            games[gameId].name = res.name || games[gameId].name;
            // Mark that we have the full server-side record so loadCurrentGame
            // doesn't immediately attempt another fetch for this game.
            games_metadata[gameId] = games_metadata[gameId] || {};
            games_metadata[gameId].roundsLoaded = true;
            games_metadata[gameId].roundCount = (games[gameId].rounds || []).length;
            games_metadata[gameId].localOnly = false;
            saveCurrentGame(false);
            // Persist local backup
            persistLocalGames();
            localStorage.setItem("cardgame-current-game", currentGameId);
          }).catch(err => {
            console.warn('Creating game on server failed, falling back to local', err);
            games[gameId].localOnly = true;
            games_metadata[gameId] = games_metadata[gameId] || {};
            games_metadata[gameId].localOnly = true;
            saveCurrentGame(false);
            persistLocalGames();
            localStorage.setItem("cardgame-current-game", currentGameId);
          });
        }
        
        // Update displays and switch to game view
        renderGameList();
        loadCurrentGame(); // Ensure the new game is properly loaded
        updateGameDisplay();
        
        // Force show game view with a small delay to ensure it happens after any other initialization
        setTimeout(() => {
          console.log("Switching to game view for new game:", gameId);
          showGame();
          console.log("Game creation completed, should be on game view now");
        }, 100);
      }
      
      
      
      function switchToGame(gameId) {
        if (games[gameId]) {
          // Save current game state before switching (local update only to avoid heavy network ops)
          saveCurrentGame(false);
          
          currentGameId = gameId;
          localStorage.setItem("cardgame-current-game", currentGameId);
          loadCurrentGame();
          updateGameDisplay(); // Update player tiles and game info
          renderGameList();
          renderPlayers(); // Update player management view
          render();
        }
      }
      
      function deleteGame(gameId) {
        // Allow deleting the last game; UI will show a 'no games' page afterwards
        
        if (!confirm("Are you sure you want to delete this game?")) {
          return;
        }
        // Back up the game in case remote delete fails and we need to restore
        let backup = null;
        if (games[gameId]) {
          try {
            backup = structuredClone(games[gameId]);
          } catch (e) {
            console.warn('deleteGame: failed to clone backup', e);
            backup = null;
          }
        }
        const wasLocalOnly = !!(games[gameId] && games[gameId].localOnly);
        
        // Remove locally immediately for snappy UI
        delete games[gameId];
        
        if (currentGameId === gameId) {
          // Clear current selection; keep UI on Games Management page
          currentGameId = null;
          try { localStorage.removeItem('cardgame-current-game'); } catch (e) { console.warn('deleteGame: failed to remove cardgame-current-game from localStorage', e); }
        }
        
        // If server is available and the game exists on server (not local-only), attempt remote delete
        if (serverAvailable && !wasLocalOnly) {
          fetch(API_BASE + '/api/games/' + encodeURIComponent(gameId), { method: 'DELETE' })
          .then(resp => {
            if (!resp.ok) throw new Error('Remote delete failed: ' + resp.status);
            console.log('deleteGame: remote delete succeeded for', gameId);
            // Persist local snapshot as backup (without deleted game)
            persistLocalGames();
          }).catch(err => {
            console.warn('deleteGame: remote delete failed, restoring local copy', err);
            // Restore local copy to avoid data loss
            if (backup) games[gameId] = backup;
            persistLocalGames();
            alert('Failed to delete game: ' + (err && err.message ? err.message : 'unknown'));
          }).finally(() => {
            // Reinitialize games to refresh state from server and stay on Games Management
            initializeGames().then(() => {
              showGamesManagement();
            }).catch(e => {
              console.warn('initializeGames after delete failed', e);
              renderGameList();
              renderGamesManagement();
              render();
            });
          });
        } else {
          // Local-only game or offline: persist local deletion only
          persistLocalGames();
          // Reinitialize games to refresh state (local-only deletion) and stay on Games Management
          initializeGames().then(() => {
            showGamesManagement();
          }).catch(e => {
            console.warn('initializeGames after local delete failed', e);
            renderGameList();
            renderGamesManagement();
            render();
          });
        }
        
        // If no games remain, show the no-games view
        if (!Object.keys(games).length) {
          currentGameId = null;
          showNoGames();
        }
      }
      
      function renderGamesManagement() {
        const gamesManagementList = document.getElementById("gamesManagementList");
        if (!gamesManagementList) return;
        
        gamesManagementList.innerHTML = "";
        // Show newest games first by parsing timestamp suffix from gameId
        const gameEntries = Object.entries(games).sort((a, b) => {
          const ta = Number(a[0].split('-').pop()) || 0;
          const tb = Number(b[0].split('-').pop()) || 0;
          return tb - ta;
        });
        gameEntries.forEach(([gameId, game]) => {
          const gameItem = document.createElement("div");
          gameItem.className = "games-management-item" + (gameId === currentGameId ? " active" : "");
          
          // Calculate game stats
          let totalRounds = getTotalRounds(game);
          const totalPlayers = getTotalPlayers(game);
          const createdText = game.createdAt ? formatTimestamp(game.createdAt) : '';
          
          gameItem.innerHTML = `
            <div style="display:flex; align-items:flex-start; justify-content:space-between; gap:12px; width:100%; box-sizing:border-box;">
              <div class="game-info" onclick="switchToGameAndView('${gameId}')" style="flex:1; min-width:0;">
                <div class="game-info-name">${game.name}${game && game.localOnly ? ' <span class="offline-badge" title="Stored locally">Local</span>' : ''}</div>
                <div class="game-info-details">${totalPlayers} players ‚Ä¢ ${totalRounds} rounds</div>
                <div class="game-info-created">${createdText}</div>
              </div>
              <div class="game-actions" style="display:flex; align-items:center; gap:8px; white-space:nowrap;">
                ${game && game.localOnly && serverAvailable ? '<button class="btn-small" data-server-action="true" onclick="syncLocalGameToServer(\'' + gameId + '\')" style="background: #28a745; color: white; padding: 8px 16px; font-size: 14px; margin-right:8px;">Sync</button>' : ''}
                <button class="btn-small" onclick="editGameName('${gameId}')" style="background: #007bff; color: white; padding: 8px 16px; font-size: 14px; margin-right:8px;">Edit</button>
                <button class="btn-small" onclick="deleteGame('${gameId}')" style="background: #dc3545; color: white; padding: 8px 16px; font-size: 14px;">Delete</button>
              </div>
            </div>
          `;
          
          gamesManagementList.appendChild(gameItem);
        });

        // Add a footer button linking to the standalone Game Visualizer
        try {
          const footer = document.createElement('div');
          footer.style.marginTop = '14px';
          footer.style.textAlign = 'center';
          footer.innerHTML = `<a class="btn" href="game-visualizer.html" target="_blank" rel="noopener" style="background:#17a2b8;color:white;padding:10px 18px;font-size:15px;text-decoration:none;border-radius:4px;display:inline-block;">Open Game Visualizer</a>`;
          gamesManagementList.appendChild(footer);
        } catch (e) { console.warn('renderGamesManagement: failed to append visualizer button', e); }
      }
      
      // Edit a game's name. Uses a prompt for simplicity and persists the change.
      function editGameName(gameId) {
        const game = games[gameId];
        if (!game) { alert('Game not found'); return; }
        try {
          openGenericEditModal('game', { gameId: gameId, originalName: game.name || '' });
        } catch (e) { console.warn('editGameName: failed to open modal', e); }
      }
      
      function switchToGameAndView(gameId) {
        switchToGame(gameId);
        showGame();
      }
      
      function renderGameList() {
        const gameList = document.getElementById("gameList");
        gameList.innerHTML = "";
        // Show newest games first by parsing timestamp suffix from gameId
        const entries = Object.entries(games).sort((a, b) => {
          const ta = Number(a[0].split('-').pop()) || 0;
          const tb = Number(b[0].split('-').pop()) || 0;
          return tb - ta;
        });
        
        entries.forEach(([gameId, game]) => {
          const gameItem = document.createElement("div");
          gameItem.className = "game-item" + (gameId === currentGameId ? " active" : "");
          
          gameItem.innerHTML = `
            <span class="game-name">${game.name}</span>
            ${game && game.localOnly ? '<span class="offline-badge" title="Stored locally">Local</span>' : ''}
          `;
          
          gameItem.onclick = () => switchToGame(gameId);
          gameList.appendChild(gameItem);
        });
      }
      
      function render() {
        // Calculate totals for legacy compatibility
        totals = [0, 0, 0, 0];
        rounds.forEach(roundData => {
          const { points } = parseRoundData(roundData);
          points.forEach((v, i) => totals[i] += v);
        });
      }
      
      function updateHistoryDisplay() {
        // Update title
        const currentGame = games[currentGameId];
        const historyTitle = document.getElementById('historyTitle');
        if (historyTitle && currentGame) {
          historyTitle.textContent = `${currentGame.name} - History`;
        }
        
        // Get all unique players who have participated
        const allPlayers = getAllHistoricalPlayers();
        
        // Calculate leader for header display using common function
        const { playerTotals, playerRounds, playerAverages } = calculatePlayerTotals();
        
        // Build player stats array for getLeader function
        const playerStats = Object.keys(playerTotals).map(name => ({
          name: name,
          avgScore: playerAverages[name],
          roundsPlayed: playerRounds[name]
        }));
        
        // Use common getLeader function to find leader(s)
        const leaderObjects = getLeader(playerStats);
        const leaders = new Set(leaderObjects.map(p => p.name));
        
        // Build dynamic table headers
        const headerRow = document.getElementById('historyTableHeader');
        buildPlayerHeaders(headerRow, allPlayers, leaders, playerRounds);
        
        renderHistory();
      }
      
      function getAllHistoricalPlayers() {
        const playerMap = new Map();
        
        // Add current active players (including empty seats)
        players.active.forEach((name, index) => {
          if (name === null) {
            const emptyName = `[Empty Seat ${index + 1}]`;
            playerMap.set(emptyName, {
              name: emptyName,
              isActive: false,
              isQueued: false,
              isEmpty: true,
              currentPosition: index
            });
          } else {
            playerMap.set(name, {
              name: name,
              isActive: true,
              isQueued: false,
              isEmpty: false,
              currentPosition: index
            });
          }
        });
        
        // Add queued players
        players.queue.forEach(name => {
          if (playerMap.has(name)) {
            // Update existing entry
            const player = playerMap.get(name);
            player.isQueued = true;
          } else {
            playerMap.set(name, {
              name: name,
              isActive: false,
              isQueued: true,
              isEmpty: false,
              currentPosition: -1
            });
          }
        });
        
        // Order players primarily by creation order (if available), then by current active/queue status, then empty seats
        const creationOrder = (games[currentGameId] && Array.isArray(games[currentGameId].playerCreationOrder)) ? games[currentGameId].playerCreationOrder.slice() : [];
        const ordered = [];
        
        // Add players in creation order first
        creationOrder.forEach(name => {
          if (playerMap.has(name)) {
            ordered.push(playerMap.get(name));
            playerMap.delete(name);
          }
        });
        
        // Then ensure currently active players appear next (in seat order) if they weren't in creationOrder
        players.active.forEach((name, idx) => {
          const key = name === null ? `[Empty Seat ${idx + 1}]` : name;
          if (playerMap.has(key)) {
            ordered.push(playerMap.get(key));
            playerMap.delete(key);
          }
        });
        
        // Then queued players in their queue order
        players.queue.forEach(name => {
          if (playerMap.has(name)) {
            ordered.push(playerMap.get(name));
            playerMap.delete(name);
          }
        });
        
        // Finally append any remaining entries: non-empty historical players (alphabetical), then empty seats (by seat index)
        const remaining = Array.from(playerMap.values());
        const nonEmptyRemain = remaining.filter(p => !p.isEmpty).sort((a,b) => a.name.localeCompare(b.name));
        const emptyRemain = remaining.filter(p => p.isEmpty).sort((a,b) => a.currentPosition - b.currentPosition);
        
        return ordered.concat(nonEmptyRemain, emptyRemain);
      }
      
      // Helper: build table headers for history/statistics using a common format
      function buildPlayerHeaders(headerRow, allPlayers, leaders = new Set(), playerRounds = {}) {
        if (!headerRow) return;
        headerRow.innerHTML = '';
        
        const roundHeader = document.createElement('th');
        roundHeader.textContent = 'Round';
        roundHeader.style.minWidth = '60px';
        headerRow.appendChild(roundHeader);
        
        allPlayers.forEach(player => {
          const playerHeader = document.createElement('th');
          if (player.isEmpty) {
            playerHeader.textContent = player.name;
            playerHeader.style.color = '#999';
            playerHeader.style.fontStyle = 'italic';
          } else {
            let headerText = player.name;
            if (leaders.has(player.name) && playerRounds[player.name] > 0) {
              headerText += ' üëë';
            }
            playerHeader.textContent = headerText;
          }
          playerHeader.style.minWidth = '80px';
          headerRow.appendChild(playerHeader);
        });
      }
      
      // Helper: initialize cumulative scores map for a list of players
      function initCumulativeScores(allPlayers) {
        const cumulativeScores = {};
        allPlayers.forEach(player => {
          if (!player.isEmpty) cumulativeScores[player.name] = 0;
        });
        return cumulativeScores;
      }
      
      // Compute totals (totals, rounds played, averages) for given rounds and players
      function computeTotals(roundsList = rounds, playersObj = players) {
        const playerTotals = {};
        const playerRounds = {};
        
        // Initialize from active and queued players
        (playersObj.active || []).forEach(name => {
          if (name !== null) {
            playerTotals[name] = 0;
            playerRounds[name] = 0;
          }
        });
        (playersObj.queue || []).forEach(name => {
          if (name !== null) {
            playerTotals[name] = 0;
            playerRounds[name] = 0;
          }
        });
        
        // Accumulate from rounds
        (roundsList || []).forEach(roundData => {
          const { points, playerNames } = parseRoundData(roundData);
          playerNames.forEach((name, i) => {
            if (name && points[i] !== null && points[i] !== undefined && points[i] !== '') {
              if (playerTotals[name] === undefined) {
                playerTotals[name] = 0;
                playerRounds[name] = 0;
              }
              playerTotals[name] += points[i];
              playerRounds[name]++;
            }
          });
        });
        
        const playerAverages = {};
        Object.keys(playerTotals).forEach(name => {
          playerAverages[name] = playerRounds[name] > 0 ? playerTotals[name] / playerRounds[name] : 0;
        });
        
        return { playerTotals, playerRounds, playerAverages };
      }
      
      // Compute cumulative snapshots per round for the provided ordered player list
      // Returns array of snapshots where snapshots[i] is totals after round i
      function computeCumulativeSnapshots(allPlayers, roundsList = rounds) {
        const snapshots = [];
        const cumulative = {};
        allPlayers.forEach(player => {
          if (!player.isEmpty) cumulative[player.name] = 0;
        });
        
        (roundsList || []).forEach(roundData => {
          const { points, playerNames } = parseRoundData(roundData);
          for (let j = 0; j < playerNames.length; j++) {
            const pname = playerNames[j];
            if (pname && points[j] !== null && points[j] !== undefined && points[j] !== '') {
              if (cumulative.hasOwnProperty(pname)) cumulative[pname] += points[j];
            }
          }
          snapshots.push({ ...cumulative });
        });
        
        return snapshots;
      }
      
      function renderHistory() {
        const tbody = document.getElementById("historyTableBody");
        const showCards = document.getElementById("showCardsToggle").checked;
        tbody.innerHTML = "";
        
        // Update description based on toggle
        const description = showCards ? "Showing: Cards left per round" : "Showing: Points scored per round";
        document.getElementById("historyDescription").textContent = description;
        
        if (rounds.length === 0) {
          const allPlayers = getAllHistoricalPlayers();
          const colspan = allPlayers.length + 1; // +1 for Round column
          tbody.innerHTML = `<tr><td colspan="${colspan}" style="text-align: center; font-style: italic;">No rounds played yet</td></tr>`;
          return;
        }
        
        // Get player order for columns
        const allPlayers = getAllHistoricalPlayers();
        
        // Compute cumulative snapshots (totals after each round) for columns
        const snapshots = computeCumulativeSnapshots(allPlayers, rounds);
        
        rounds.forEach((roundData, i) => {
          const tr = document.createElement("tr");
          
          // Parse round data using common function
          const { points, playerNames, cards } = parseRoundData(roundData);
          const displayValues = showCards ? cards : points;
          const currentSnapshot = snapshots[i] || {};
          
          // Round number column
          const roundCell = document.createElement('td');
          roundCell.textContent = '#' + (i + 1);
          roundCell.style.fontWeight = 'bold';
          tr.appendChild(roundCell);
          
          // Player data columns
          allPlayers.forEach(player => {
            const cell = document.createElement('td');
            
            if (player.isEmpty) {
              // Empty seat - no data
              cell.textContent = '-';
              cell.style.color = '#999';
            } else {
              // Find this player's score for this round by name
              let playerValue = '-';
              
              for (let j = 0; j < playerNames.length; j++) {
                if (playerNames[j] === player.name && displayValues[j] !== null && displayValues[j] !== undefined && displayValues[j] !== '') {
                  playerValue = displayValues[j];
                  break;
                }
              }
              
              // Style based on value
              if (playerValue === 0) {
                // Winner (0 points or 0 cards left)
                cell.style.backgroundColor = '#90ee90'; // light green
                cell.style.fontWeight = 'bold';
                // Add cumulative score in parenthesis
                if (currentSnapshot[player.name] === undefined) {
                  cell.textContent = '0 üèÜ';
                } else {
                  cell.textContent = `0 (${currentSnapshot[player.name]}) üèÜ`;
                }
              } else if (playerValue === '-') {
                cell.textContent = '-';
                cell.style.color = '#999';
              } else {
                const numValue = Number(playerValue);
                
                // Apply color coding using common function
                cell.style.backgroundColor = getScoreColor(numValue, showCards);
                
                cell.textContent = playerValue;
                // Add cumulative score in parenthesis for both cards and points view
                if (currentSnapshot[player.name] !== undefined) {
                  cell.textContent += ` (${currentSnapshot[player.name]})`;
                }
              }
            }
            
            tr.appendChild(cell);
          });
          
          tbody.appendChild(tr);
        });
        
        // Add total row at the bottom with avg score
        const totalRow = document.createElement('tr');
        totalRow.style.fontWeight = 'bold';
        totalRow.style.borderTop = '2px solid #333';
        totalRow.style.backgroundColor = '#f0f0f0';
        
        const totalLabelCell = document.createElement('td');
        totalLabelCell.textContent = 'Total';
        totalLabelCell.style.backgroundColor = '#f0f0f0';
        totalRow.appendChild(totalLabelCell);
        
        // Calculate player averages using centralized totals API
        const relevantNames = allPlayers.filter(p => !p.isEmpty).map(p => p.name);
        const totalsObj = computeTotals(rounds, { active: relevantNames, queue: [] });
        const playerAverages = {};
        Object.keys(totalsObj.playerTotals).forEach(name => {
          const rp = totalsObj.playerRounds[name] || 0;
          if (rp > 0) {
            playerAverages[name] = { avg: totalsObj.playerAverages[name], roundsPlayed: rp };
          }
        });
        
        allPlayers.forEach(player => {
          const cell = document.createElement('td');
          cell.style.backgroundColor = '#f0f0f0';
          if (player.isEmpty) {
            cell.textContent = '-';
            cell.style.color = '#999';
          } else {
            const avgData = playerAverages[player.name];
            
            if (avgData && avgData.roundsPlayed > 0) {
              const total = (snapshots.length ? (snapshots[snapshots.length - 1][player.name] || 0) : 0);
              // Show total, then newline, then avg with prefix
              cell.innerHTML = `${total}<br><span style="font-weight:normal; font-size:12px; color:#333;">avg. ${avgData.avg.toFixed(1)}</span>`;
            } else {
              cell.textContent = '-';
              cell.style.color = '#999';
            }
          }
          totalRow.appendChild(cell);
        });
        
        // Modify total label cell to include avg. label on next line
        totalLabelCell.innerHTML = 'Total<br><span style="font-weight:normal; font-size:12px; color:#333;">avg.</span>';
        totalLabelCell.style.backgroundColor = '#f0f0f0';
        
        // Append total row
        tbody.appendChild(totalRow);
      }
      
      function reverseCalculateCards(points) {
        // Approximate reverse calculation for old data
        if (points === 0) return 0;
        if (points <= 7) return points; // 1x multiplier
        if (points <= 18) return Math.round(points / 2); // 2x multiplier
        if (points <= 36) return Math.round(points / 3); // 3x multiplier
        return Math.round(points / 4); // 4x multiplier
      }
      
      function toggleHistoryView() {
        renderHistory();
      }
      
      function deleteLastRound() {
        if (rounds.length === 0) {
          alert('No rounds to delete');
          return;
        }
        
        if (!confirm('Are you sure you want to delete the last round?')) {
          return;
        }
        
        // Remove the last round
        rounds.pop();
        
        // Recompute totals by replaying remaining rounds and recalc elimination state
        // Recalculate eliminationLevels based on current totals (50-point levels)
        const totalsObj = calculatePlayerTotals();
        const totals = totalsObj.playerTotals || {};
        
        // Recompute eliminationLevels from totals
        eliminationLevels = {};
        // Ensure all known players are included
        Object.keys(totals).forEach(name => {
          eliminationLevels[name] = Math.floor((totals[name] || 0) / 50);
        });
        
        // Determine whether the one-time 25-point rule has been used by replaying rounds
        let used25 = false;
        let used25By = null;
        const runningTotals = {};
        for (const rd of rounds) {
          const parsed = parseRoundData(rd);
          const pts = parsed.points || [0,0,0,0];
          const pnames = parsed.playerNames || [null,null,null,null];
          for (const [i, pname] of pnames.entries()) {
            if (!pname) continue;
            runningTotals[pname] = (runningTotals[pname] || 0) + (Number(pts[i]) || 0);
            if (!used25 && runningTotals[pname] >= 25) {
              used25 = true;
              used25By = pname;
              break;
            }
          }
          if (used25) break;
        }
        elimination25UsedBy = used25By || null;
        try { setElimination25UsedBy(elimination25UsedBy); } catch (e) { console.warn('Failed to set elimination25UsedBy via setter after replay', e); }
        // Ensure the player who was eliminated at 25 is recorded as having reached level 1
        if (elimination25UsedBy) {
          eliminationLevels[elimination25UsedBy] = Math.max(eliminationLevels[elimination25UsedBy] || 0, 1);
        }
        
        // Persist and update UI
        // Update local game object without issuing the normal remote PUT (which strips rounds)
        saveCurrentGame(false);
        
        // If server is available and this game is not local-only, push the full game state
        // (including updated `rounds`) so the server reflects the deletion.
        if (serverAvailable && games[currentGameId] && !games[currentGameId].localOnly) {
          fetch(API_BASE + '/api/games/' + encodeURIComponent(currentGameId), {
            method: 'PUT',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ id: currentGameId, name: games[currentGameId].name, data: games[currentGameId] })
          }).then(resp => {
            if (!resp.ok) throw new Error('Remote update failed: ' + resp.status);
            console.log('deleteLastRound: remote update succeeded for', currentGameId);
            try { persistLocalGames(); } catch (e) { console.warn('persistLocalGames failed', e); }
          }).catch(err => {
            console.warn('deleteLastRound: remote update failed, falling back to full save', err);
            // Fallback to full persist (this will trigger saveGames and local backup)
            saveCurrentGame(true);
          });
        } else {
          // Local-only or offline: persist locally
          persistLocalGames();
        }
        
        updateGameDisplay();
        renderHistory();
        renderStatistics();
      }
      
      function calculateStatistics() {
        // This function now only calculates totalRounds and leader
        // Detailed player statistics are calculated in renderStatistics()
        
        if (rounds.length === 0) {
          return {
            totalRounds: 0,
            leader: '-'
          };
        }
        
        // Use common function to calculate player totals
        const { playerRounds, playerAverages } = calculatePlayerTotals();
        
        // Find current leader (lowest average score, then most rounds as tiebreaker)
        let leader;
        const playerAvgArray = Object.entries(playerAverages)
        .filter(([name, avg]) => playerRounds[name] > 0)
        .map(([name, avg]) => ({ name, avg: avg, rounds: playerRounds[name] }));
        
        if (playerAvgArray.length > 0) {
          const minAvg = Math.min(...playerAvgArray.map(p => p.avg));
          const playersWithMinAvg = playerAvgArray.filter(p => p.avg === minAvg);
          
          // Apply tiebreaker: most rounds played
          const maxRounds = Math.max(...playersWithMinAvg.map(p => p.rounds));
          const leaders = playersWithMinAvg.filter(p => p.rounds === maxRounds);
          
          if (leaders.length === 1) {
            leader = leaders[0].name;
          } else if (leaders.length > 1) {
            leader = 'Tied: ' + leaders.map(p => p.name).join(', ');
          } else {
            leader = '-';
          }
        }
        
        return {
          totalRounds: rounds.length,
          leader
        };
      }
      
      function renderStatistics() {
        try {
          const statsTitleEl = document.getElementById('statisticsTitle');
          if (statsTitleEl) statsTitleEl.textContent = games[currentGameId]?.name + ' - Statistics' || 'Game Statistics';
        } catch (e) { console.warn('renderStatistics: failed to update statistics title', e); }
        const stats = calculateStatistics();
        const tbody = document.getElementById('statisticsTableBody');
        tbody.innerHTML = '';
        
        // Get all unique players who have ever participated
        const allPlayerNames = new Set();
        
        // Add current active players (including nulls for empty seats)
        players.active.forEach((name, index) => {
          if (name === null) {
            allPlayerNames.add(`[Empty Seat ${index + 1}]`);
          } else {
            allPlayerNames.add(name);
          }
        });
        
        // Add queued players
        players.queue.forEach(name => allPlayerNames.add(name));
        
        // Add any players who participated in rounds but aren't currently active/queued
        rounds.forEach(roundData => {
          const { points } = parseRoundData(roundData);
          
          points.forEach((p, i) => {
            if (p !== null && p !== undefined && p !== '') {
              // Find what player was in position i during historical rounds
              const playerName = players.active[i];
              if (playerName) {
                allPlayerNames.add(playerName);
              }
            }
          });
        });
        
        // Create player data array with comprehensive stats
        const playerData = [];
        Array.from(allPlayerNames).forEach(playerName => {
          // Skip empty seat placeholders
          if (playerName && playerName.startsWith('[Empty Seat')) {
            const seatNumber = playerName.match(/\[Empty Seat (\d+)\]/)?.[1];
            if (seatNumber) {
              playerData.push({
                name: playerName,
                total: 0,
                average: 0,
                wins: 0,
                winRate: 0,
                avgCards: 0,
                pointsMade: 0,
                roundsPlayed: 0,
                isEmpty: true,
                seatIndex: Number.parseInt(seatNumber) - 1
              });
            }
            return;
          }
          
          // Calculate comprehensive stats for this player
          let totalScore = 0;
          let roundsPlayed = 0;
          let wins = 0;
          let totalCards = 0;
          let cardsRoundsPlayed = 0;
          let pointsMade = 0;
          
          rounds.forEach(roundData => {
            const { points, cards, playerNames: roundPlayers } = parseRoundData(roundData);
            
            // Find this player's position in THIS SPECIFIC round
            let playerIndex = -1;
            
            if (roundPlayers && roundPlayers[0] !== null) {
              // Use stored player names to find correct position
              playerIndex = roundPlayers.indexOf(playerName);
            } else {
              // Fallback for old data: use current position (may be inaccurate)
              playerIndex = players.active.indexOf(playerName);
            }
            
            // Only process if player was in this round
            if (playerIndex !== -1 && points[playerIndex] !== null && points[playerIndex] !== undefined && points[playerIndex] !== '') {
              const playerScore = points[playerIndex];
              totalScore += playerScore;
              roundsPlayed++;
              
              // Check if player won this round (0 cards left)
              if (cards[playerIndex] === 0) {
                wins++;
                // Calculate points made: sum of other players' points in this round
                const otherPlayersPoints = points.reduce((sum, p, i) => {
                  return (i !== playerIndex && p !== null && p !== undefined && p !== '') ? sum + p : sum;
                }, 0);
                pointsMade += otherPlayersPoints;
              }
              
              if (cards[playerIndex] !== null && cards[playerIndex] !== undefined) {
                totalCards += cards[playerIndex];
                cardsRoundsPlayed++;
              }
            }
          });
          
          playerData.push({
            name: playerName,
            total: totalScore,
            average: roundsPlayed > 0 ? totalScore / roundsPlayed : 0,
            wins: wins,
            winRate: roundsPlayed > 0 ? (wins / roundsPlayed) * 100 : 0,
            avgCards: cardsRoundsPlayed > 0 ? totalCards / cardsRoundsPlayed : 0,
            pointsMade: pointsMade,
            roundsPlayed: roundsPlayed,
            isEmpty: false,
            isQueued: players.queue.includes(playerName),
            isActive: players.active.includes(playerName)
          });
        });
        
        // Sort by average score (ascending - lower is better), with special handling
        playerData.sort((a, b) => {
          // Empty seats go to the end
          if (a.isEmpty && b.isEmpty) return a.seatIndex - b.seatIndex;
          if (a.isEmpty) return 1;
          if (b.isEmpty) return -1;
          
          // Non-players go after players but before empty seats
          if (a.roundsPlayed === 0 && b.roundsPlayed === 0) {
            // Among non-players, active players first, then queued
            if (a.isActive && !b.isActive) return -1;
            if (!a.isActive && b.isActive) return 1;
            return a.name.localeCompare(b.name);
          }
          if (a.roundsPlayed === 0) return 1;
          if (b.roundsPlayed === 0) return -1;
          
          // Among players who played, sort by average
          return a.average - b.average;
        });
        
        // Populate table rows
        // Determine leaders using common function (handles ties)
        const playerStatsForLeader = playerData
        .filter(p => !p.isEmpty && p.roundsPlayed > 0)
        .map(p => ({ name: p.name, avgScore: p.average, roundsPlayed: p.roundsPlayed }));
        const leaderObjects = getLeader(playerStatsForLeader);
        const leaderNames = new Set(leaderObjects.map(l => l.name));
        
        playerData.forEach((player) => {
          const tr = document.createElement('tr');
          
          // Styling based on player status
          if (player.isEmpty) {
            tr.style.color = '#999';
            tr.style.fontStyle = 'italic';
          } else if (player.roundsPlayed === 0) {
            tr.style.color = '#666';
            tr.style.fontStyle = 'italic';
          }
          
          // Highlight leaders (may be multiple)
          if (leaderNames.has(player.name) && player.roundsPlayed > 0) {
            tr.style.backgroundColor = '#e8f5e8';
            tr.style.fontWeight = 'bold';
          }
          
          let displayName = player.name;
          if (player.isActive && !player.isEmpty) {
            displayName += ' ‚òÖ';
          }
          
          tr.innerHTML = `
            <td style="font-weight: 500;">${displayName}</td>
            <td>${player.roundsPlayed > 0 ? player.total : '-'}</td>
            <td>${player.roundsPlayed > 0 ? player.average.toFixed(1) : '-'}</td>
            <td>${player.roundsPlayed > 0 ? player.roundsPlayed : '-'}</td>
            <td>${player.roundsPlayed > 0 ? player.wins : '-'}</td>
            <td>${player.roundsPlayed > 0 ? player.winRate.toFixed(1) + '%' : '-'}</td>
            <td>${player.roundsPlayed > 0 ? player.avgCards.toFixed(1) : '-'}</td>
            <td>${player.roundsPlayed > 0 ? player.pointsMade : '-'}</td>
          `;
          tbody.appendChild(tr);
        });
        
        // Update game summary
        document.getElementById('totalRounds').textContent = stats.totalRounds;
      }
      
      function showStatistics() {
        switchView('statisticsView');
        document.getElementById('statisticsTitle').textContent = games[currentGameId]?.name + ' - Statistics' || 'Game Statistics';
        renderStatistics();
      }
      
      function calculatePoints(cardsLeft) {
        const cards = Number(cardsLeft);
        if (cards === 0) return 0;
        if (cards >= 1 && cards <= 7) return cards * 1;
        if (cards >= 8 && cards <= 9) return cards * 2;
        if (cards >= 10 && cards <= 12) return cards * 3;
        if (cards >= 13) return cards * 4;
        return 0;
      }
      
      // Common function to get background color based on value
      function getScoreColor(value, isCards = true) {
        const numValue = Number(value) || 0;
        
        if (numValue === 0) {
          return '#90ee90'; // light green (winner)
        }
        
        if (isCards) {
          // Color by cards
          if (numValue >= 1 && numValue <= 7) return '#ffffff'; // white
          if (numValue >= 8 && numValue <= 9) return '#ffcccc'; // light red
          if (numValue >= 10 && numValue <= 12) return '#ff9999'; // darker red
          if (numValue >= 13) return '#ff6666'; // even darker red
        } else {
          // Color by points
          if (numValue >= 1 && numValue <= 7) return '#ffffff'; // white
          if (numValue >= 8 && numValue <= 18) return '#ffcccc'; // light red
          if (numValue >= 19 && numValue <= 36) return '#ff9999'; // darker red
          if (numValue >= 37) return '#ff6666'; // even darker red
        }
        
        return '#ffffff'; // default white
      }
      
      function updatePointsDisplay() {
        const inputs = ['p1Score', 'p2Score', 'p3Score', 'p4Score'];
        const pointsElements = ['p1Points', 'p2Points', 'p3Points', 'p4Points'];
        
        inputs.forEach((inputId, index) => {
          const inputElement = document.getElementById(inputId);
          const cardsLeft = inputElement.value;
          const points = calculatePoints(cardsLeft);
          document.getElementById(pointsElements[index]).textContent = `Points: ${points}`;
          
          // Update input background based on cards left
          const cards = Number(cardsLeft) || 0;
          if (cardsLeft === '' || cardsLeft === null || cardsLeft === undefined) {
            inputElement.style.backgroundColor = '';
          } else {
            inputElement.style.backgroundColor = getScoreColor(cards, true);
          }
        });
      }
      
      function showAddRoundModal() {
        const modal = document.getElementById("addRoundModal");
        modal.style.display = "block";
        // Push a history state so the back button can close the modal instead
        try {
          if (!history.state || history.state.modal !== 'addRound') {
            history.pushState({ modal: 'addRound' }, '');
            globalThis._addRoundStatePushed = true;
          }
        } catch (e) { console.warn('showAddRoundModal: history.pushState failed', e); }
        
        // Update labels with actual player names
        const labels = modal.querySelectorAll('label[for^="p"]');
        labels.forEach((label, i) => {
          const playerName = players.active[i] || `Empty Seat ${i + 1}`;
          label.textContent = `${playerName}:`;
        });
        
        // Reset input values to empty
        resetRoundForm('clear');
        // Ensure overlay state is cleared when opening
        try {
          globalThis._addingRound = false;
          const overlay = document.getElementById('addRoundOverlay'); if (overlay) overlay.style.display = 'none';
          const confirmBtn = document.getElementById('confirmRoundBtn'); if (confirmBtn) confirmBtn.disabled = false;
          const addRoundBtnEl = document.getElementById('addRoundBtn'); if (addRoundBtnEl) addRoundBtnEl.disabled = false;
          const closeBtns = modal.querySelectorAll('.close'); if (closeBtns && closeBtns.length) closeBtns.forEach(b => { try { b.disabled = false; } catch(e) { console.warn('Failed to enable modal close button', e); } });
        } catch (e) { console.warn('Failed to reset add-round modal state on show', e); }
        
        // Focus first input
        document.getElementById("p1Score").focus();
      }
      
      function closeAddRoundModal() {
        // Prevent closing while a round save is in progress
        if (globalThis._addingRound) return;
        document.getElementById("addRoundModal").style.display = "none";
        // If we previously pushed a history state for the modal, remove it so
        // subsequent back presses don't attempt to re-open or double-close it.
        try {
          if (history.state && history.state.modal === 'addRound') {
            history.back();
          }
        } catch (e) { console.warn('closeAddRoundModal: history.back failed', e); }
      }
      
      // When the user presses the browser back button, if the add-round modal
      // is open we should close it instead of navigating away.
      globalThis.addEventListener('popstate', function (ev) {
        try {
          // If any of our known modals are open, close the top-most one.
          const modalIds = ['addRoundModal', 'genericEditModal', 'replacementModal'];
          for (const id of modalIds) {
            const m = document.getElementById(id);
            if (m && (m.style.display === 'block' || m.style.display === 'flex')) {
              m.style.display = 'none';
              // clear any editing state
              if (id === 'genericEditModal') globalThis._genericEdit = null;
              return;
            }
          }
          
          // No modal was open ‚Äî handle view navigation and double-back-to-exit on root.
          const state = ev && ev.state ? ev.state : (history.state || null);
          const targetView = state && state.view ? state.view : null;
          // If this was our dummy trap state, handle intelligently:
          // - If the user was not already on the game view (i.e. they are returning from deeper navigation),
          //   navigate to the game view instead of showing the toast.
          // - If the user is already on the game view, show the toast.
          if (state && state.dummy) {
            const currentViewNow = (typeof getCurrentView === 'function') ? getCurrentView() : null;
            if (currentViewNow && currentViewNow !== 'game') {
              try { showGame(); } catch (e) { console.warn('popstate: failed to navigate to game on dummy state', e); }
              return;
            }
            const now = Date.now();
            globalThis._backWarningTime = now;
            try { showBackToast('Press back again to exit'); } catch (e) { console.warn('popstate: showBackToast failed', e); }
            try { history.pushState({ view: 'game', root: true }, ''); } catch (e) { console.warn('popstate: history.pushState failed', e); }
            return;
          }
          const current = (typeof getCurrentView === 'function') ? getCurrentView() : null;
          
          // If the popped state contains a view and it's different from current, navigate to it
          if (targetView && targetView !== current) {
            try {
              if (targetView === 'game') showGame();
              else if (targetView === 'players') showPlayers();
              else if (targetView === 'history') showHistory();
              else if (targetView === 'statistics') showStatistics();
              else if (targetView === 'newgame') showNewGame();
              else if (targetView === 'games') showGamesManagement();
            } catch (e) { console.warn('popstate: failed to navigate to view', targetView, e); }
            return;
          }
          
          // If we're on the main game view and there's no previous view to go to,
          // implement "press back twice to exit" behavior: on first back show a toast
          // and re-push the game state; on second within timeframe allow navigation.
          if (current === 'game') {
            const now = Date.now();
            if (!globalThis._backWarningTime || (now - globalThis._backWarningTime) > 2000) {
              globalThis._backWarningTime = now;
              try { showBackToast('Press back again to exit'); } catch (e) { console.warn('popstate: showBackToast failed', e); }
              return;
            }
            // second back within timeframe ‚Äî allow default behavior (do nothing)
          }
        } catch (err) { console.warn('popstate handler failed', err); }
      });
      
      // Close modal when clicking on the overlay (outside modal-content)
      document.addEventListener('click', function (ev) {
        try {
          const target = ev.target;
          if (!target || !target.classList) return;
          if (!target.classList.contains('modal')) return;
          // clicked on modal overlay
          const id = target.id;
          if (id === 'addRoundModal') {
            closeAddRoundModal();
          } else if (id === 'genericEditModal') {
            cancelGenericEditModal();
          } else if (id === 'replacementModal') {
            closeReplacementModal();
          } else {
            // generic: hide it
            try { target.style.display = 'none'; } catch (e) { console.warn('Modal overlay click: failed to hide target', e); }
          }
        } catch (err) { console.warn('Modal overlay click handler failed', err); }
      });
      
      // Helper: push a view state onto history (used for SPA navigation)
      function pushViewState(view) {
        try {
          if (!history.state || history.state.view !== view) {
            history.pushState({ view: view }, '');
          }
        } catch (e) { console.warn('pushViewState failed', e); }
      }
      
      // Small toast to notify user about back-to-exit behavior
      function showBackToast(msg) {
        try {
          let t = document.getElementById('backToast');
          if (!t) {
            t = document.createElement('div');
            t.id = 'backToast';
            document.body.appendChild(t);
          }
          t.textContent = msg || 'Press back again to exit';
          t.style.opacity = '1';
          setTimeout(() => { try { t.style.opacity = '0'; } catch (e) { console.warn('showBackToast: fade failed', e); } }, 1600);
        } catch (e) { console.warn('showBackToast failed', e); }
      }
      
      // Visual debug indicator for popstate/back handling
      function showDebugIndicator(msg, timeout = 1800) {
        try {
          let el = document.getElementById('backDebug');
          if (!el) {
            el = document.createElement('div');
            el.id = 'backDebug';
            document.body.appendChild(el);
          }
          el.textContent = String(msg || 'popstate');
          el.style.display = 'block';
          el.style.opacity = '1';
          setTimeout(() => { try { el.style.opacity = '0'; } catch (e) { console.warn('showDebugIndicator: fade failed', e); } }, timeout - 300);
          setTimeout(() => { try { el.style.display = 'none'; } catch (e) { console.warn('showDebugIndicator: hide failed', e); } }, timeout);
        } catch (e) { console.warn('showDebugIndicator failed', e); }
      }
      
      function showHistory() {
        switchView('historyView');
        updateHistoryDisplay();
      }
      
      function showGame() {
        // If there are no games or no current game selected, show the no-games view
        if (!currentGameId || Object.keys(games || {}).length === 0 || !games[currentGameId]) {
          showNoGames();
          return;
        }
        
        switchView('gameView');
        updateGameDisplay();
      }
      
      function showPlayers() {
        const currentGame = games[currentGameId];
        const playersTitle = document.getElementById('playersTitle');
        if (playersTitle && currentGame) {
          playersTitle.textContent = `${currentGame.name} - Player Management`;
        }
        switchView('playersView');
        renderPlayers();
      }
      
      function showGamesManagement() {
        switchView('gamesManagementView');
        renderGamesManagement();
        try { pushViewState('games'); } catch (e) { console.warn('showGamesManagement: pushViewState failed', e); }
        closeSidebar();
      }
      // Helpers to split confirmRound logic for readability and testability
      function _getRoundCardsFromForm() {
        return [
        Number(document.getElementById("p1Score").value || 0),
        Number(document.getElementById("p2Score").value || 0),
        Number(document.getElementById("p3Score").value || 0),
        Number(document.getElementById("p4Score").value || 0)
        ];
      }
      
      function _validateCards(cards) {
        const winners = cards.filter(c => c === 0);
        if (winners.length === 0) return { ok: false, msg: 'There must be exactly one winner (one player with 0 cards left).' };
        if (winners.length > 1) return { ok: false, msg: 'There can only be one winner (only one player can have 0 cards left).' };
        return { ok: true };
      }
      
      function _computePoints(cards) {
        return cards.map(c => calculatePoints(Number(c) || 0));
      }
      
      function _snapshotPlayers() {
        return [players.active[0] || null, players.active[1] || null, players.active[2] || null, players.active[3] || null];
      }
      
      function _applyEliminations(prevTotals, playersBefore, points) {
        // Recompute new totals and determine candidates
        const newTotals = { ...prevTotals };
        for (let i = 0; i < playersBefore.length; i++) {
          const name = playersBefore[i];
          if (!name) continue;
          const add = Number(points[i]) || 0;
          if (newTotals[name] === undefined) newTotals[name] = 0;
          newTotals[name] += add;
        }
        
        // Prepare 50-point candidates
        const candidates = [];
        for (let i = 0; i < playersBefore.length; i++) {
          const name = playersBefore[i];
          if (!name) continue;
          const prev = prevTotals[name] || 0;
          const prevLevels = eliminationLevels[name] || 0;
          const nextThreshold = (prevLevels + 1) * 50;
          const newTotal = newTotals[name];
          if (newTotal >= nextThreshold) {
            const overshoot = newTotal - nextThreshold;
            const newLevelsReached = Math.floor(newTotal / 50);
            candidates.push({ name, prev, overshoot, slotIndex: i, newLevelsReached });
          }
        }
        
        candidates.sort((a, b) => {
          if (b.overshoot !== a.overshoot) return b.overshoot - a.overshoot;
          return (b.prev || 0) - (a.prev || 0);
        });
        
        // Reset last replacements for this round
        lastReplacements = [];
        
        // ONE-TIME 25-point rule
        if (!elimination25UsedBy) {
          const candidates25 = [];
          for (let i = 0; i < playersBefore.length; i++) {
            const name = playersBefore[i];
            if (!name) continue;
            const prev = prevTotals[name] || 0;
            const newTotal = newTotals[name] || 0;
            if (prev < 25 && newTotal >= 25) {
              const overshoot = newTotal - 25;
              candidates25.push({ name, prev, overshoot, slotIndex: i, newTotal });
            }
          }
          if (candidates25.length > 0) {
            candidates25.sort((a, b) => {
              if (b.overshoot !== a.overshoot) return b.overshoot - a.overshoot;
              return (b.prev || 0) - (a.prev || 0);
            });
            const c = candidates25[0];
            const slotIdx = c.slotIndex;
            const slotPlayer = players.active[slotIdx];
            if (slotPlayer === c.name) {
              // Mark the one-time 25-point elimination as used for this game
              // and treat the eliminated player as having reached elimination level 1
              // so their next automatic elimination threshold will be at 100.
              if (players.queue.length === 0) {
                lastReplacements.push({ slotIndex: slotIdx, eliminated: c.name, replacement: null, skipped: true });
              } else {
                const replacement = players.queue.shift();
                players.queue.push(c.name);
                players.active[slotIdx] = replacement || null;
                lastReplacements.push({ slotIndex: slotIdx, eliminated: c.name, replacement: replacement });
              }
              elimination25UsedBy = c.name;
              try { setElimination25UsedBy(c.name); } catch (e) { console.warn('Failed to set elimination25UsedBy via setter', e); }
              eliminationLevels[c.name] = Math.max(eliminationLevels[c.name] || 0, 1);
            }
          }
        }
        
        // Process 50-point eliminations
        candidates.forEach(candidate => {
          const currentIndex = players.active.indexOf(candidate.name);
          if (currentIndex === -1) return;
          if (players.queue.length === 0) {
            eliminationLevels[candidate.name] = candidate.newLevelsReached;
            lastReplacements.push({ slotIndex: currentIndex, eliminated: candidate.name, replacement: null, skipped: true });
            return;
          }
          const replacement = players.queue.shift();
          players.queue.push(candidate.name);
          players.active[currentIndex] = replacement || null;
          eliminationLevels[candidate.name] = candidate.newLevelsReached;
          lastReplacements.push({ slotIndex: currentIndex, eliminated: candidate.name, replacement: replacement });
        });
      }
      
      // Reset the add-round modal inputs. `mode` can be 'clear' (empty strings)
      // or 'zero' (set values to "0"). Always updates the points display.
      function resetRoundForm(mode = 'clear') {
        try {
          const ids = ['p1Score', 'p2Score', 'p3Score', 'p4Score'];
          if (mode === 'zero') {
            ids.forEach(id => { const el = document.getElementById(id); if (el) el.value = '0'; });
          } else {
            ids.forEach(id => { const el = document.getElementById(id); if (el) el.value = ''; });
          }
          updatePointsDisplay();
        } catch (e) {
          console.warn('resetRoundForm failed', e);
        }
      }
      
      async function _persistRoundAndSync(roundData) {
        // Append locally first
        rounds.push(roundData);
        // Update local games object now (no remote PUT)
        saveCurrentGame(false);
        
        if (currentGameId) {
          const game = games[currentGameId];
          if (serverAvailable && game && !game.localOnly) {
            await postRoundWithFallback(currentGameId, roundData);
          } else {
            try { persistLocalGames(); } catch (e) { console.warn('confirmRound: persistLocalGames failed', e); }
          }
        } else {
          saveCurrentGame(true);
        }
      }
      
      // Attempts to append a round to the server via POST /games/:id/rounds.
      // On success it will persist metadata-only via saveGame(gameId, false).
      // If append fails it will fall back to issuing a full PUT of the game
      // (including `rounds`) via saveGame(gameId, true). If that also fails
      // it will persist locally as a last resort.
      async function postRoundWithFallback(gameId, roundData) {
        if (!gameId || !games[gameId]) return;
        try {
          const resp = await fetch(API_BASE + '/api/games/' + encodeURIComponent(gameId) + '/rounds', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ round: roundData })
          });
          if (!resp.ok) throw new Error('Remote append failed: ' + resp.status);
          try {
            await saveGame(gameId, false);
          } catch (e) {
            console.warn('postRoundWithFallback: saving metadata after append failed', e);
          }
          return;
        } catch (err) {
          console.warn('postRoundWithFallback: append failed, attempting full-game PUT', err);
          try {
            await saveGame(gameId, true);
            return;
          } catch (e) {
            console.warn('postRoundWithFallback: full-game PUT failed, falling back to local persist', e);
            try { saveCurrentGame(true); } catch (ex) { console.warn('postRoundWithFallback: local persist failed', ex); }
          }
        }
      }
      
      async function confirmRound() {
        // Prevent re-entry
        if (globalThis._addingRound) return;
        globalThis._addingRound = true;
        const cards = _getRoundCardsFromForm();
        const valid = _validateCards(cards);
        if (!valid.ok) {
          alert('Invalid round: ' + valid.msg);
          // clear adding state and re-enable controls so the user can correct input
          try { globalThis._addingRound = false; } catch (e) { console.warn('Failed to clear _addingRound flag after validation failure', e); }
          try { const overlay = document.getElementById('addRoundOverlay'); if (overlay) overlay.style.display = 'none'; } catch (e) { console.warn('Failed to hide addRoundOverlay after validation failure', e); }
          try { const confirmBtn = document.getElementById('confirmRoundBtn'); if (confirmBtn) confirmBtn.disabled = false; } catch (e) { console.warn('Failed to re-enable confirm button after validation failure', e); }
          try { const addRoundBtnEl = document.getElementById('addRoundBtn'); if (addRoundBtnEl) addRoundBtnEl.disabled = false; } catch (e) { console.warn('Failed to re-enable add-round button after validation failure', e); }
          return;
        }
        const points = _computePoints(cards);
        const playersBefore = _snapshotPlayers();
        const prevTotalsObj = calculatePlayerTotals();
        const prevTotals = prevTotalsObj.playerTotals || {};
        
        // Disable confirm controls to prevent accidental double-presses
        const confirmBtn = document.getElementById('confirmRoundBtn');
        const addRoundBtnEl = document.getElementById('addRoundBtn');
        const modal = document.getElementById('addRoundModal');
        const closeButtons = modal ? modal.querySelectorAll('.close') : [];
        try {
          // show overlay and mark saving state
          const overlay = document.getElementById('addRoundOverlay');
          if (overlay) overlay.style.display = 'flex';
          if (closeButtons && closeButtons.length) closeButtons.forEach(b => { try { b.disabled = true; } catch (e) { console.warn('Failed to disable modal close button', e); } });
          if (confirmBtn) confirmBtn.disabled = true;
          if (addRoundBtnEl) addRoundBtnEl.disabled = true;
        } catch (e) { console.warn('Failed to disable add-round buttons', e); }
        
        // Apply elimination rules which may mutate `players`, `players.queue`, `eliminationLevels`, and `lastReplacements`.
        _applyEliminations(prevTotals, playersBefore, points);
        
        const roundData = { players: playersBefore.map(p => p || null), cards: cards, points: points, timestamp: Date.now() };
        console.log('confirmRound: preparing to add round', { currentGameId, serverAvailable, roundData });
        
        try {
          await _persistRoundAndSync(roundData);
          
          // Reset inputs and update UI
          // clear adding flag and hide overlay so the modal can close
          try { globalThis._addingRound = false; } catch (e) { console.warn('Failed to clear _addingRound flag', e); }
          try { const overlay = document.getElementById('addRoundOverlay'); if (overlay) overlay.style.display = 'none'; } catch (e) { console.warn('Failed to hide addRoundOverlay', e); }
          resetRoundForm('zero');
          closeAddRoundModal();
          if (lastReplacements && lastReplacements.length > 0) {
            const _replSnapshot = lastReplacements.slice();
            // Delay showing replacement modal slightly to avoid race with closing add-round modal
            setTimeout(() => {
              try { showReplacementModal(_replSnapshot); } catch (e) { console.warn('Delayed showReplacementModal failed', e); }
            }, 50);
          }
          updateGameDisplay();
          render();
        } finally {
          // clear saving state, hide spinner, re-enable controls
          globalThis._addingRound = false;
          try { const overlay = document.getElementById('addRoundOverlay'); if (overlay) overlay.style.display = 'none'; } catch (e) { console.warn('Failed to hide addRoundOverlay', e); }
          try { if (closeButtons && closeButtons.length) closeButtons.forEach(b => { try { b.disabled = false; } catch (e) { console.warn('Failed to enable modal close button', e); } }); } catch (e) { console.warn('Failed to re-enable modal close buttons', e); }
          try {
            if (confirmBtn) confirmBtn.disabled = false;
            if (addRoundBtnEl) addRoundBtnEl.disabled = false;
          } catch (e) { console.warn('Failed to re-enable add-round buttons', e); }
        }
      }
      
      function resetGame() {
        if (!confirm("Reset all scores for this game?")) return;
        rounds = [];
        saveCurrentGame();
        render();
      }
      
      // Replacement modal helpers
      function showReplacementModal(replacements) {
        const list = document.getElementById('replacementList');
        if (!list) return;
        if (!replacements || replacements.length === 0) {
          list.innerHTML = '<div style="font-style: italic; padding:8px;">No replacements</div>';
        } else {
          list.innerHTML = replacements.map(r => {
            const seat = `Seat #${r.slotIndex + 1}`;
            const desc = r.replacement
            ? `${r.eliminated} was eliminated and replaced by ${r.replacement}.`
            : `${r.eliminated} was eliminated and no replacement was available.`;
            return `
              <div class="replacement-item">
                <div class="replacement-seat">${seat}</div>
                <div class="replacement-desc">${desc}</div>
              </div>
            `;
          }).join('');
        }
        const modal = document.getElementById('replacementModal');
        if (modal) {
          console.log('showReplacementModal: opening replacement modal, entries=', replacements.length);
          // Force a centered overlay so it is visible on all screens
          try {
            modal.style.display = 'flex';
            modal.style.alignItems = 'center';
            modal.style.justifyContent = 'center';
            modal.style.zIndex = '2000';
          } catch (e) { console.warn('showReplacementModal: failed to apply styles to modal', e); }
          try { modal.setAttribute('tabindex', '-1'); modal.focus(); } catch (e) { console.warn('showReplacementModal: failed to focus modal', e); }
          try {
            if (!history.state || history.state.modal !== 'replacement') {
              history.pushState({ modal: 'replacement' }, '');
              globalThis._replacementStatePushed = true;
            }
          } catch (e) { console.warn('showReplacementModal: history.pushState failed', e); }
        }
      }
      
      function closeReplacementModal() {
        const modal = document.getElementById('replacementModal');
        if (modal) modal.style.display = 'none';
        try {
          if (history.state && history.state.modal === 'replacement') history.back();
        } catch (e) { console.warn('closeReplacementModal: history.back failed', e); }
      }
      
      // Handle Enter key in new game input
      document.addEventListener("DOMContentLoaded", function() {
        const newGameNameInput = document.getElementById("newGameNameInput");
        if (newGameNameInput) {
          newGameNameInput.addEventListener("keypress", function(e) {
            if (e.key === "Enter") {
              createNewGameWithPlayers();
            }
          });
        }
        // Also prefill quick-create input if present
        const quickInput = document.getElementById('newGameInput');
        if (quickInput) {
          const today = new Date();
          const dd = String(today.getDate()).padStart(2, '0');
          const mm = String(today.getMonth() + 1).padStart(2, '0');
          const yyyy = today.getFullYear();
          quickInput.value = `${dd}.${mm}.${yyyy}`;
        }
        
        // Close modal when clicking outside
        const addRoundModal = document.getElementById("addRoundModal");
        if (addRoundModal) {
          addRoundModal.addEventListener("click", function(e) {
            if (e.target === this) {
              closeAddRoundModal();
            }
          });
        }
        
        // Handle Enter key in modal inputs
        const modalInputs = ["p1Score", "p2Score", "p3Score", "p4Score"];
        modalInputs.forEach(inputId => {
          document.getElementById(inputId).addEventListener("keypress", function(e) {
            if (e.key === "Enter") {
              if (globalThis._addingRound) {
                e.preventDefault();
                return;
              }
              confirmRound();
            }
          });
        });
        
        // Handle Escape key to close modal (disabled while saving)
        document.addEventListener("keydown", function(e) {
          if (e.key === "Escape") {
            if (globalThis._addingRound) return;
            closeAddRoundModal();
            closeReplacementModal();
          }
        });
        // Reflect initial sidebar visibility and keep it updated on resize
        updateSidebarVisibilityClass();
        applyButtonVisibility();
        window.addEventListener('resize', function() { updateSidebarVisibilityClass(); applyButtonVisibility(); });
        // Ensure No Games view is visible immediately to avoid transient game flashes
        try { showNoGames(); renderGameList(); renderGamesManagement(); } catch (e) { console.warn('Initial render/showNoGames failed (not ready yet)', e); }
      });
      
      // Immediately load any locally saved games so UI shows them while server responds
      try {
        const storedSync = safeLoadStoredGames();
        if (storedSync && typeof storedSync === 'object' && Object.keys(storedSync).length > 0) {
          // Only preload locally-created games (explicit localOnly === true)
          const localOnlyGames = {};
          Object.keys(storedSync).forEach(id => {
            try {
              if (storedSync[id] && storedSync[id].localOnly === true) localOnlyGames[id] = storedSync[id];
            } catch (e) { console.warn('Immediate local load: failed to read stored entry', id, e); }
          });
          if (Object.keys(localOnlyGames).length > 0) {
            games = localOnlyGames;
            // Mark loaded stored games in client-only metadata (they are assumed fully loaded)
            try {
              initLocalOnlyGamesMetadata(localOnlyGames, 'Immediate local load');
            } catch (e) { console.warn('Immediate local load: failed to initialize games_metadata', e); }
            // restore last-open game if known, otherwise pick the first
            currentGameId = localStorage.getItem('cardgame-current-game') || Object.keys(games)[0];
            renderGameList();
            renderGamesManagement();
            loadCurrentGame();
            updateGameDisplay();
            render();
          }
        }
      } catch (e) {
        console.warn('Immediate local load failed', e);
      }
      
      // Allow skipping the initial server ping to avoid noisy DevTools errors
      // Use URL param `?skipServer=1` or set `globalThis.SKIP_SERVER_PING = true` before loading.
      const params_skip = new URLSearchParams(location.search || '').get('skipServer');
      if (params_skip === '1' || globalThis.SKIP_SERVER_PING === true) {
        serverAvailable = false;
        updateConnectionIndicator();
      } else {
        await testServerConnection();
      }
      await initializeGames();
      // If server is available, start realtime WebSocket updates (server must provide WS at API_BASE + '/ws')
      if (serverAvailable && typeof globalThis.initRealtimeWebSocket === 'function') {
        globalThis.initRealtimeWebSocket();
      }
      // If server is not available, ensure we only expose local-only games.
      // If local games were already loaded synchronously earlier, keep them and skip extra filtering.
      if (!serverAvailable) {
        try {
          if (games && Object.keys(games).length > 0) {
            // Local games already present (loaded before server ping)
            updateConnectionIndicator();
            renderGameList();
            renderGamesManagement();
          } else {
            const localEntries = Object.entries(games || {}).filter(([id, g]) => g && g.localOnly);
            if (localEntries.length > 0) {
              games = Object.fromEntries(localEntries);
              if (!games[currentGameId]) {
                currentGameId = Object.keys(games)[0];
                localStorage.setItem('cardgame-current-game', currentGameId);
              }
              try { persistLocalGames(); } catch (e) { console.warn('persistLocalGames failed', e); }
              renderGameList();
              renderGamesManagement();
            } else if (!Object.keys(games || {}).length) {
              // No local games found ‚Äî keep empty and show the no-games UI
              games = {};
              currentGameId = null;
              renderGameList();
              renderGamesManagement();
              showNoGames();
            }
          }
        } catch (e) {
          console.warn('Offline filtering of games failed', e);
        }
      }
      updateGameDisplay();
      render();
      // After initialization, if we have a current game selected show it;
      // otherwise keep the No Games view visible.
      try {
        if (currentGameId && games[currentGameId]) {
          // Ensure full game data is loaded and then show game view
          loadCurrentGame();
          showGame();
        } else {
          showNoGames();
        }
      } catch (e) { console.warn('updateServerActionStates call failed', e); }
      try {
        // Set initial history state to current view so back navigation works predictably
        const initialView = (typeof getCurrentView === 'function') ? getCurrentView() : 'game';
        history.replaceState({ view: initialView, root: true }, '');
        // Push a dummy trap state so pressing back once triggers popstate instead of leaving the app
        try { history.pushState({ view: initialView, dummy: true }, ''); } catch (e) { console.warn('initial history.pushState failed', e); }
      } catch (e) { console.warn('initial history.replaceState failed', e); }
      // When online, merge any locally stored `localOnly` games so they remain visible
      if (serverAvailable) {
        try {
          const stored = safeLoadStoredGames();
          let merged = false;
          if (stored && typeof stored === 'object') {
            Object.entries(stored).forEach(([id, g]) => {
              if (g && g.localOnly && !games[id]) {
                games[id] = g;
                merged = true;
              }
            });
          }
          if (merged) {
            // Ensure currentGameId still points to a valid game
            if (!games[currentGameId]) {
              currentGameId = Object.keys(games)[0];
              localStorage.setItem('cardgame-current-game', currentGameId);
            }
            renderGameList();
            renderGamesManagement();
          }
        } catch (e) {
          console.warn('Merging local games while online failed', e);
        }
      }
      
      // Reveal UI now initialization completed to avoid transient flashes
      try { document.body.classList.remove('preinit'); } catch (e) { console.warn('remove preinit class failed', e); }
      
      // --- Elimination tests moved to external file: elimination-tests.js ---
      // Backwards-compatible stub: delegates to external loader if present
      function runEliminationTests() {
        if (typeof globalThis.runEliminationTestsExternal === 'function') {
          return globalThis.runEliminationTestsExternal();
        }
        alert('Elimination tests are not loaded. Include tests/elimination-tests.js to run them.');
      }
      // Backwards-compatible stub for unit tests
      function runUnitTests() {
        if (typeof globalThis.runUnitTestsExternal === 'function') {
          return globalThis.runUnitTestsExternal();
        }
        alert('Unit tests are not loaded. Include tests/unit-tests.js to run them.');
      }
      // Backwards-compatible stub for integration tests
      function runIntegrationTests() {
        if (typeof globalThis.runIntegrationTestsExternal === 'function') {
          return globalThis.runIntegrationTestsExternal();
        }
        alert('Integration tests are not loaded. Include tests/integration-tests.js to run them.');
      }
      
      // Mobile Menu Functions
      // Keep a body class in sync with sidebar visibility so desktop-only rules can target it
      function updateSidebarVisibilityClass() {
        const sidebar = document.querySelector('.sidebar');
        if (!sidebar) return;
        
        // On desktop sizes, the sidebar is always visible in the layout ‚Äî treat it as shown.
        if (window.innerWidth >= 769) {
          document.body.classList.add('sidebar-visible');
          return;
        }
        
        // For mobile, treat sidebar as visible only when it has the explicit 'open' class
        if (sidebar.classList.contains('open')) {
          document.body.classList.add('sidebar-visible');
        } else {
          document.body.classList.remove('sidebar-visible');
        }
      }
      
      // Enforce button visibility based on sidebar-visible state on desktop
      function applyButtonVisibility() {
        const shouldHide = window.innerWidth >= 769 && document.body.classList.contains('sidebar-visible');
        const bottomBtns = document.querySelectorAll('.game-secondary-menu-btn');
        bottomBtns.forEach(b => { if (b) b.style.display = shouldHide ? 'none' : ''; });
      }
      function toggleSidebar() {
        const sidebar = document.querySelector('.sidebar');
        const overlay = document.querySelector('.sidebar-overlay');
        
        sidebar.classList.toggle('open');
        if (sidebar.classList.contains('open')) {
          overlay.classList.add('active');
          document.body.style.overflow = 'hidden';
        } else {
          overlay.classList.remove('active');
          document.body.style.overflow = '';
        }
        // Update body class for desktop targeting
        updateSidebarVisibilityClass();
        applyButtonVisibility();
      }
      
      function closeSidebar() {
        const sidebar = document.querySelector('.sidebar');
        const overlay = document.querySelector('.sidebar-overlay');
        
        sidebar.classList.remove('open');
        overlay.classList.remove('active');
        document.body.style.overflow = '';
        // Update body class for desktop targeting
        updateSidebarVisibilityClass();
        applyButtonVisibility();
      }
      
      // Close sidebar when navigating on mobile
      const originalShowGame = showGame;
      const originalShowPlayers = showPlayers;
      const originalShowStatistics = showStatistics;
      const originalShowHistory = showHistory;
      const originalShowNewGame = showNewGame;
      
      showGame = function() {
        originalShowGame();
        try { pushViewState('game'); } catch (e) { console.warn('showGame: pushViewState failed', e); }
        if (window.innerWidth <= 768) closeSidebar();
      };
      
      showPlayers = function() {
        originalShowPlayers();
        try { pushViewState('players'); } catch (e) { console.warn('showPlayers: pushViewState failed', e); }
        if (window.innerWidth <= 768) closeSidebar();
      };
      
      showStatistics = function() {
        originalShowStatistics();
        try { pushViewState('statistics'); } catch (e) { console.warn('showStatistics: pushViewState failed', e); }
        if (window.innerWidth <= 768) closeSidebar();
      };
      
      showHistory = function() {
        originalShowHistory();
        try { pushViewState('history'); } catch (e) { console.warn('showHistory: pushViewState failed', e); }
        if (window.innerWidth <= 768) closeSidebar();
      };
      
      showNewGame = function() {
        originalShowNewGame();
        try { pushViewState('newgame'); } catch (e) { console.warn('showNewGame: pushViewState failed', e); }
        if (window.innerWidth <= 768) closeSidebar();
      };
      
      // Expose functions to global scope for inline handlers (modules are module-scoped)
      // Expose selected functions and state to globalThis so external test scripts can access them.
      // Include runtime state (`players`, `rounds`) and utility functions used by tests.
      const __expose = [
      'toggleSidebar','closeSidebar','showGame','showPlayers','showStatistics','showHistory',
      'showNewGame','showGamesManagement','showAddRoundModal','closeAddRoundModal','confirmRound','deleteLastRound','addPlayer','addPlayerInput',
      'removePlayerInput','deleteGame','createNewGameWithPlayers','createNewGame','clearNewGameInputs',
      'cancelEditPlayerName','activatePlayerToSeat','activatePlayer','editPlayerName','editGameName','openGenericEditModal','confirmGenericEditModal','cancelGenericEditModal','genericEditModal',
      'demotePlayer','toggleAddPlayerForm','switchToGameAndView','showReplacementModal','closeReplacementModal',
      'toggleHistoryView','updatePointsDisplay','updateConnectionIndicator','syncLocalGameToServer',
      // Expose runtime state and helper functions so tests can run against the live app
      'players','rounds','games','currentGameId','eliminationLevels','elimination25UsedBy','parseRoundData','calculatePlayerTotals','calculatePoints','reverseCalculateCards','computeTotals','computeCumulativeSnapshots','loadCurrentGame','formatTimestamp','getTotalPlayers',
      'setCurrentGameId','persistLocalGames','saveCurrentGame','setServerAvailable','runEliminationTests','runUnitTests','runIntegrationTests'
      ];
      
      __expose.forEach(name => {
        try {
          if (globalThis[name] !== undefined) return; // already exposed
          // Attempt to evaluate the name in module scope; for objects this will be a reference
          const val = eval(name);
          if (val !== undefined) {
            globalThis[name] = val;
          }
        } catch (e) {
          console.debug(`__expose: failed to expose ${name}`, e);
        }
      });

      async function tryLoadVariants(label, candidates) {
        for (const url of candidates) {
          try {
            const resp = await fetch(url);
            if (!resp.ok) continue;
            const text = await resp.text();
            if (!text) continue;
            const t = String(text).trim();
            if (!t || t[0] === '<') continue; // looks like HTML
            const s = document.createElement('script');
            s.text = text;
            document.body.appendChild(s);
            console.log(label + ' loaded from ' + url);
            return true;
          } catch (e) {
            console.debug('tryLoadVariants: fetch failed for ' + url + ', trying next', e);
          }
        }
        console.log(label + ' not found via candidate paths, skipping');
        return false;
      }
      
      const baseCandidates = ['tests/'];
      function candidatesFor(name) { return baseCandidates.map(p => p + name); }
      
      // Load test variants sequentially using top-level await so failures are visible
      await tryLoadVariants('elimination-tests.js', candidatesFor('elimination-tests.js'));
      await tryLoadVariants('unit-tests.js', candidatesFor('unit-tests.js'));
      await tryLoadVariants('integration-tests.js', candidatesFor('integration-tests.js'));
    </script>
    
    <!-- PWA install button and service worker registration -->
    <button id="installBtn" style="display:none;position:fixed;right:16px;bottom:16px;z-index:2000" class="btn-large bg-blue">Install</button>
    <script type="module">
      // Service worker registration ‚Äî use top-level await for clarity
      if ('serviceWorker' in navigator) {
        try {
          const reg = await navigator.serviceWorker.register('/service-worker.js');
          console.log('ServiceWorker registered', reg);
        } catch (err) {
          console.warn('SW register failed', err);
        }
      }
      
      // beforeinstallprompt handling for showing an install button
      let deferredPrompt = null;
      const installBtn = document.getElementById('installBtn');
      globalThis.addEventListener('beforeinstallprompt', (e) => {
        // Note: do not call e.preventDefault() here to avoid a console warning
        // if prompt() is never called. Store the event for manual prompting
        deferredPrompt = e;
        if (installBtn) installBtn.style.display = 'block';
      });
      
      if (installBtn) installBtn.addEventListener('click', async () => {
        if (!deferredPrompt) return;
        deferredPrompt.prompt();
        const choice = await deferredPrompt.userChoice;
        deferredPrompt = null;
        installBtn.style.display = 'none';
        console.log('User install choice', choice);
      });
    </script>
  </div>
</body>
</html>
    